<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sympoly</title>
  <meta name="keywords" content="sympoly">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # src --><!-- ../menu.html utils --><!-- menu.html quadfit -->
<h1>sympoly
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../src/@RemoteControlBoardRemapper/open.html" class="code" title="function open(obj,partList,jointsList)">open</a>	</li><li><a href="latexgreek.html" class="code" title="function s = latexgreek(s)">latexgreek</a>	Replace all recognized Greek letters with their LaTeX equivalents.</li><li><a href="merge.html" class="code" title="function [c,ia,ib] = merge(a, b)">merge</a>	Merge two sorted arrays.</li><li><a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>	Convert a numeric value to a string in the specified format.</li><li><a href="strjoin.html" class="code" title="function string = strjoin(items, adjoiner)">strjoin</a>	Concatenate a cell array of strings.</li><li><a href="sympoly.html" class="code" title="">sympoly</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="ellipsoid_ex2im.html" class="code" title="function p = ellipsoid_ex2im(center, radii, R)">ellipsoid_ex2im</a>	Cast ellipsoid defined with explicit parameters to implicit vector form.</li><li><a href="quadmake.html" class="code" title="function quadmake(kind)">quadmake</a>	Builds covariance matrices for quadratic forms.</li><li><a href="symcrosscov.html" class="code" title="function C = symcrosscov(phi1, phi2, sysvars)">symcrosscov</a>	Compensation for observation cross-covariance matrix.</li><li><a href="sympoly.html" class="code" title="">sympoly</a>	</li><li><a href="sympolys.html" class="code" title="function sympolys(varargin)">sympolys</a>	Create multiple symbolic polynomials in the caller workspace.</li><li><a href="test_sympoly.html" class="code" title="function test_sympoly">test_sympoly</a>	Test suite for symbolic polynomial manipulation.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function sp = sympoly(varargin)</a></li><li><a href="#_sub2" class="code">function tf = eq(sp1, sp2)</a></li><li><a href="#_sub3" class="code">function tf = ne(sp1, sp2)</a></li><li><a href="#_sub4" class="code">function sp = conj(sp)</a></li><li><a href="#_sub5" class="code">function sp = ctranspose(sp)</a></li><li><a href="#_sub6" class="code">function sp = real(sp)</a></li><li><a href="#_sub7" class="code">function sp = imag(sp)</a></li><li><a href="#_sub8" class="code">function d = double(sp)</a></li><li><a href="#_sub9" class="code">function sp = uplus(sp)</a></li><li><a href="#_sub10" class="code">function sp = uminus(sp)</a></li><li><a href="#_sub11" class="code">function sp = plus(sp1, sp2)</a></li><li><a href="#_sub12" class="code">function sp = minus(sp1, sp2)</a></li><li><a href="#_sub13" class="code">function sp = times(sp1,sp2)</a></li><li><a href="#_sub14" class="code">function sp = mtimes(sp1,sp2)</a></li><li><a href="#_sub15" class="code">function sp = rdivide(sp1, sp2)</a></li><li><a href="#_sub16" class="code">function sp = mrdivide(sp1,sp2)</a></li><li><a href="#_sub17" class="code">function sp = ldivide(sp1, sp2)</a></li><li><a href="#_sub18" class="code">function sp = mldivide(sp1, sp2)</a></li><li><a href="#_sub19" class="code">function [q,r,rflag] = quorem(sp1, sp2)</a></li><li><a href="#_sub20" class="code">function [q,r,rflag] = syndivide(sp1, sp2)</a></li><li><a href="#_sub21" class="code">function sp = power(sp,n)</a></li><li><a href="#_sub22" class="code">function sp = mpower(sp,n)</a></li><li><a href="#_sub23" class="code">function spd = diag(sp)</a></li><li><a href="#_sub24" class="code">function prodp = prod(sp, varargin)</a></li><li><a href="#_sub25" class="code">function sump = sum(sp, varargin)</a></li><li><a href="#_sub26" class="code">function sp = modexpon(sp, p)</a></li><li><a href="#_sub27" class="code">function sp = sqrt(sp)</a></li><li><a href="#_sub28" class="code">function vars = variables(sp)</a></li><li><a href="#_sub29" class="code">function tf = isconstant(sp)</a></li><li><a href="#_sub30" class="code">function tf = islinear(sp)</a></li><li><a href="#_sub31" class="code">function tf = isunivariate(sp)</a></li><li><a href="#_sub32" class="code">function tf = ismonomial(sp)</a></li><li><a href="#_sub33" class="code">function tf = issinglevariable(sp)</a></li><li><a href="#_sub34" class="code">function tf = issingleterm(sp)</a></li><li><a href="#_sub35" class="code">function spd = det(sp)</a></li><li><a href="#_sub36" class="code">function di = defint(sp, varargin)</a></li><li><a href="#_sub37" class="code">function sp = idefint(sp, varargin)</a></li><li><a href="#_sub38" class="code">function sp = int(sp, varargin)</a></li><li><a href="#_sub39" class="code">function dpdx = diff(sp, varargin)</a></li><li><a href="#_sub40" class="code">function gradp = gradient(sp)</a></li><li><a href="#_sub41" class="code">function r = roots(sp)</a></li><li><a href="#_sub42" class="code">function deg = degree(sp, varargin)</a></li><li><a href="#_sub43" class="code">function deg = maxdegree(sp, varargin)</a></li><li><a href="#_sub44" class="code">function deg = mindegree(sp, varargin)</a></li><li><a href="#_sub45" class="code">function [spterms,spcoeff] = terms(sp)</a></li><li><a href="#_sub46" class="code">function [coeff,terms] = coeffterms(sp, powers, varargin)</a></li><li><a href="#_sub47" class="code">function [coeff,terms] = coeffs(sp, varargin)</a></li><li><a href="#_sub48" class="code">function sp = subs(sp, old, new)</a></li><li><a href="#_sub49" class="code">function sp = subspower(sp, old, new)</a></li><li><a href="#_sub50" class="code">function [polymean,polyvar] = errorprop(sp, vars, means, stds)</a></li><li><a href="#_sub51" class="code">function [polymean,polyvar] = polyerrorprop(sp, vars, means, stds)</a></li><li><a href="#_sub52" class="code">function cp = poly(sp, var)</a></li><li><a href="#_sub53" class="code">function sp = renamevars(sp, from, to)</a></li><li><a href="#_sub54" class="code">function poly = sym2poly(sp)</a></li><li><a href="#_sub55" class="code">function [expr,vars] = sym(sp)</a></li><li><a href="#_sub56" class="code">function str = code(sp, varargin)</a></li><li><a href="#_sub57" class="code">function str = latex(sp)</a></li><li><a href="#_sub58" class="code">function str = string(sp, cformat)</a></li><li><a href="#_sub59" class="code">function str = char(sp)</a></li><li><a href="#_sub60" class="code">function disp(sp)</a></li><li><a href="#_sub61" class="code">function display(sp)</a></li><li><a href="#_sub62" class="code">function sp = convertpoly(p, var)</a></li><li><a href="#_sub63" class="code">function sympoly_object = convertsym(sym_object)</a></li><li><a href="#_sub64" class="code">function ix = findvarinset(var, vars)</a></li><li><a href="#_sub65" class="code">function ix = findvar(sp, var)</a></li><li><a href="#_sub66" class="code">function sp = sortvars(sp)</a></li><li><a href="#_sub67" class="code">function [sp1,sp2] = unionvars(sp1, sp2)</a></li><li><a href="#_sub68" class="code">function sp = clean(sp)</a></li><li><a href="#_sub69" class="code">function tf = equals(lhs, rhs)</a></li><li><a href="#_sub70" class="code">function res = add(lhs, rhs)</a></li><li><a href="#_sub71" class="code">function res = multiply(lhs, rhs)</a></li><li><a href="#_sub72" class="code">function sp = scalardivide(sp1, sp2)</a></li><li><a href="#_sub73" class="code">function [q,r,rflag] = longdivide(lhs, rhs)</a></li><li><a href="#_sub74" class="code">function [q,r,rflag] = syntheticdivide(lhs, rhs)</a></li><li><a href="#_sub75" class="code">function dpdx = differentiate(sp, n, dvar)</a></li><li><a href="#_sub76" class="code">function sp = substitute(sp, old, new)</a></li><li><a href="#_sub77" class="code">function sp = substitutepower(sp, old, new)</a></li><li><a href="#_sub78" class="code">function polymean = errormean(sp, vars, means, stds)</a></li><li><a href="#_sub79" class="code">function [expr,vars] = symobject(sp)</a></li><li><a href="#_sub80" class="code">function str = formatmatrix(sp, fun, colsep, rowsep, linesep, open, close)</a></li><li><a href="#_sub81" class="code">function sympoly_object = convertscalarsym(sym_object)</a></li><li><a href="#_sub82" class="code">function symassignincaller(sym_object)</a></li><li><a href="#_sub83" class="code">function sv = variablename(sp, var)</a></li><li><a href="#_sub84" class="code">function dim = operatingdimension(sp, dim)</a></li><li><a href="#_sub85" class="code">function var = univariatesym(sp)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="sympoly.html" class="code" title="">sympoly</a>
0002 <span class="comment">% Symbolic polynomial array of multiple variables.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Symbolic polynomials are sums of symbolic terms captured with the syntax</span>
0005 <span class="comment">% p = sum( c_i * prod( x_ij^p_ij ) ) + k</span>
0006 <span class="comment">% where the summation is over i, and the product over j and</span>
0007 <span class="comment">% * c_i is the set of polynomial term coefficients</span>
0008 <span class="comment">% * x_ij is a set of symbolic variables</span>
0009 <span class="comment">% * p_ij is the (usually integer) exponent of each variable in a term where at</span>
0010 <span class="comment">%   least one p_ij ~= 0 for a given i</span>
0011 <span class="comment">% * k is the constant term</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% For a list of supported operations on symbolic polynomials, type</span>
0014 <span class="comment">% &gt;&gt; methods sympoly</span>
0015 <span class="comment">% For details on a particular operation, type &quot;help sympoly.operation&quot;, e.g.</span>
0016 <span class="comment">% &gt;&gt; help sympoly.plus</span>
0017 
0018 <span class="comment">% References:</span>
0019 <span class="comment">% John D'Errico, &quot;Symbolic Polynomial Manipulation&quot;, MatLab Central File</span>
0020 <span class="comment">%    Exchange, http://www.mathworks.com/matlabcentral/fileexchange/9577</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% This is an extended version of the original implementation using</span>
0023 <span class="comment">% new-style MatLab classes (declared with classdef keyword).</span>
0024 
0025 <span class="comment">% Copyright 2009-2011 Levente Hunyadi</span>
0026 
0027     properties (SetAccess = protected)
0028         ConstantValue = 0;          <span class="comment">% Polynomial constant term.</span>
0029         Variables = cell(1,0);      <span class="comment">% Variable row vector.</span>
0030         Exponents = zeros(0,0);     <span class="comment">% Exponent matrix. Each column corresponds to a variable and each row belongs to a different term.</span>
0031         Coefficients = zeros(0,1);  <span class="comment">% Coefficient column vector. Each element is the coefficient of a different term.</span>
0032     <span class="keyword">end</span>
0033     methods
0034         <a name="_sub0" href="#_subfunctions" class="code">function sp = sympoly(varargin)</a>
0035         <span class="comment">% Create a(n array of) symbolic polynomial object(s).</span>
0036         <span class="comment">%</span>
0037         <span class="comment">% Usage:</span>
0038         <span class="comment">%    P = sympoly</span>
0039         <span class="comment">%    P = sympoly(scalar_numeric_variable)</span>
0040         <span class="comment">%    P = sympoly(array_numeric_variable)</span>
0041         <span class="comment">%    P = sympoly('variablename')</span>
0042         <span class="comment">%    P = sympoly(size1, size2, ...)</span>
0043         <span class="comment">%    sympolys varname1 varname2 varname3 ...</span>
0044         <span class="comment">%</span>
0045         <span class="comment">% Input arguments:</span>
0046         <span class="comment">% var:</span>
0047         <span class="comment">%    character string that represents a valid Matlab variable name</span>
0048         <span class="comment">%    (e.g. 'x') or any scalar constant or array of constants</span>
0049         <span class="comment">%</span>
0050         <span class="comment">% Examples:</span>
0051         <span class="comment">% &gt;&gt; P = sympoly          % creates a constant monomial, P(x) = 0</span>
0052         <span class="comment">% &gt;&gt; P = sympoly('x')     % creates a linear monomial, P(x) = x</span>
0053         <span class="comment">% &gt;&gt; P = sympoly(1)       % creates a constant monomial == 1, P(x) = 1</span>
0054         <span class="comment">% &gt;&gt; P = sympoly(hilb(3)) % creates a 3x3 matrix of constant sympoly</span>
0055         <span class="comment">%                           variables, in this case a 3x3 Hilbert matrix</span>
0056         <span class="comment">% &gt;&gt; P = sympoly(3,3)     % creates an array of empty sympoly objects of the</span>
0057         <span class="comment">%                           specified size</span>
0058         <span class="comment">% &gt;&gt; sympolys a b x y     % creates sympoly variables with those names in</span>
0059         <span class="comment">%                           the caller workspace; this call is equivalent</span>
0060         <span class="comment">%                           to 4 separate calls:</span>
0061         <span class="comment">%                              a = sympoly('a')</span>
0062         <span class="comment">%                              b = sympoly('b')</span>
0063         <span class="comment">%                              x = sympoly('x')</span>
0064         <span class="comment">%                              y = sympoly('y')</span>
0065         <span class="comment">% &gt;&gt; syms x y             % creates Symbolic Toolbox variables and...</span>
0066         <span class="comment">% &gt;&gt; P = sympoly(x)       % converts a sym object to a sympoly object</span>
0067         <span class="comment">% &gt;&gt; P = sympoly(4*x^2+y) % converts a symbolic expression to a sympoly object</span>
0068         <span class="comment">% &gt;&gt; Q = sympoly(P)       % copies an existing sympoly</span>
0069         <span class="comment">%</span>
0070         <span class="comment">% See also: sympolys</span>
0071 
0072             <span class="keyword">switch</span> nargin
0073                 <span class="keyword">case</span> 0  <span class="comment">% sympoly</span>
0074                     <span class="comment">% create a scalar sympoly as a constant</span>
0075                 <span class="keyword">case</span> 1
0076                     inp = varargin{1};
0077                     <span class="keyword">if</span> isa(inp, <span class="string">'sympoly'</span>)  <span class="comment">% copy constructor</span>
0078                         sp.ConstantValue = inp.ConstantValue;
0079                         sp.Variables = inp.Variables;
0080                         sp.Exponents = inp.Exponents;
0081                         sp.Coefficients = inp.Coefficients;
0082                     <span class="keyword">elseif</span> ischar(inp)  <span class="comment">% a string that contains the name of a new sympoly</span>
0083                         <span class="keyword">if</span> nargout == 0  <span class="comment">% assign a variable with this name in the caller workspace</span>
0084                             assignin(<span class="string">'caller'</span>, inp, <a href="sympoly.html" class="code" title="">sympoly</a>(inp));
0085                         <span class="keyword">else</span>  <span class="comment">% create a sympoly, to be returned as an output</span>
0086                             sp.Variables = {inp};
0087                             sp.Exponents = [1]; <span class="comment">%#ok&lt;NBRAK&gt;</span>
0088                             sp.Coefficients = [1]; <span class="comment">%#ok&lt;NBRAK&gt;</span>
0089                         <span class="keyword">end</span>
0090                     <span class="keyword">elseif</span> isnumeric(inp)  <span class="comment">% a numeric scalar or array</span>
0091                         <span class="keyword">if</span> isscalar(inp)
0092                             sp.ConstantValue = inp;
0093                         <span class="keyword">else</span>
0094                             sz = num2cell(size(inp));
0095                             <span class="keyword">if</span> numel(inp) &gt; 0
0096                                 sp(sz{:}) = <a href="sympoly.html" class="code" title="">sympoly</a>;  <span class="comment">% initialize object array with empty constructor</span>
0097                                 <span class="keyword">if</span> nnz(inp) &gt; 0  <span class="comment">% if there are nonzero elements to set</span>
0098                                     <span class="keyword">for</span> k = 1 : numel(inp)
0099                                         sp(k).ConstantValue = inp(k);  <span class="comment">% use linear indexing in initialization</span>
0100                                     <span class="keyword">end</span>
0101                                 <span class="keyword">end</span>
0102                             <span class="keyword">else</span>
0103                                 sp = sympoly.empty(sz{:});
0104                             <span class="keyword">end</span>
0105                         <span class="keyword">end</span>
0106                     <span class="keyword">elseif</span> isa(inp, <span class="string">'symvariable'</span>)  <span class="comment">% a symbolic variable name</span>
0107                         sp.Variables = inp;
0108                         sp.Exponents = [1]; <span class="comment">%#ok&lt;NBRAK&gt;</span>
0109                         sp.Coefficients = [1]; <span class="comment">%#ok&lt;NBRAK&gt;</span>
0110                     <span class="keyword">elseif</span> isa(inp, <span class="string">'sym'</span>)
0111                         sp = sympoly.convertsym(inp);
0112                     <span class="keyword">end</span>
0113                 <span class="keyword">otherwise</span>
0114                     assert(~iscellstr(varargin), <span class="keyword">...</span><span class="comment">  % sympoly x y z  --or--  sympoly('x','y','z')</span>
0115                         <span class="string">'math:sympolys:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
0116                         <span class="string">'Multiple symbolic polynomials can be created with &quot;sympolys x y z w&quot;.'</span>);
0117                     sp = sympoly.empty(0,0);
0118                     sp(varargin{:}) = <a href="sympoly.html" class="code" title="">sympoly</a>;  <span class="comment">% expand sympoly array to specified size</span>
0119             <span class="keyword">end</span>
0120         <span class="keyword">end</span>
0121 
0122         <a name="_sub1" href="#_subfunctions" class="code">function tf = eq(sp1, sp2)</a>
0123         <span class="comment">% Test equality of a symbolic polynomial object to another or a numeric value.</span>
0124         <span class="comment">%</span>
0125         <span class="comment">% See also: eq</span>
0126 
0127             <span class="keyword">if</span> isa(sp1, <span class="string">'sympoly'</span>)
0128                 tf = <a href="#_sub69" class="code" title="subfunction tf = equals(lhs, rhs)">equals</a>(sp1, sp2);
0129             <span class="keyword">else</span>
0130                 tf = <a href="#_sub69" class="code" title="subfunction tf = equals(lhs, rhs)">equals</a>(sp2, sp1);
0131             <span class="keyword">end</span>
0132         <span class="keyword">end</span>
0133 
0134         <a name="_sub2" href="#_subfunctions" class="code">function tf = ne(sp1, sp2)</a>
0135         <span class="comment">% Test inequality of a symbolic polynomial object to another or a numeric value.</span>
0136         <span class="comment">%</span>
0137         <span class="comment">% See also: ne</span>
0138 
0139             tf = ~<a href="#_sub2" class="code" title="subfunction tf = eq(sp1, sp2)">eq</a>(sp1, sp2);
0140         <span class="keyword">end</span>
0141 
0142         <a name="_sub3" href="#_subfunctions" class="code">function sp = conj(sp)</a>
0143         <span class="comment">% Complex conjugate of the coefficients of a symbolic polynomial.</span>
0144         <span class="comment">%</span>
0145         <span class="comment">% See also: conj</span>
0146 
0147             <span class="keyword">if</span> isscalar(sp)
0148                 sp.Coefficients = <a href="#_sub4" class="code" title="subfunction sp = conj(sp)">conj</a>(sp.Coefficients);
0149             <span class="keyword">else</span>
0150                 <span class="keyword">for</span> k = 1 : numel(sp)
0151                     sp(k).Coefficients = <a href="#_sub4" class="code" title="subfunction sp = conj(sp)">conj</a>(sp(k).Coefficients);
0152                 <span class="keyword">end</span>
0153             <span class="keyword">end</span>
0154         <span class="keyword">end</span>
0155 
0156         <a name="_sub4" href="#_subfunctions" class="code">function sp = ctranspose(sp)</a>
0157         <span class="comment">% Complex conjugate transpose of symbolic polynomial array.</span>
0158         <span class="comment">%</span>
0159         <span class="comment">% See also: transpose</span>
0160 
0161             sp = <a href="#_sub4" class="code" title="subfunction sp = conj(sp)">conj</a>(sp.');
0162         <span class="keyword">end</span>
0163 
0164         <a name="_sub5" href="#_subfunctions" class="code">function sp = real(sp)</a>
0165         <span class="comment">% Real part of the coefficients of a symbolic polynomial.</span>
0166         <span class="comment">%</span>
0167         <span class="comment">% See also: real</span>
0168 
0169             <span class="keyword">if</span> isscalar(sp)
0170                 sp.Coefficients = <a href="#_sub6" class="code" title="subfunction sp = real(sp)">real</a>(sp.Coefficients);
0171             <span class="keyword">else</span>
0172                 <span class="keyword">for</span> k = 1 : numel(sp)
0173                     sp(k).Coefficients = <a href="#_sub6" class="code" title="subfunction sp = real(sp)">real</a>(sp(k).Coefficients);
0174                 <span class="keyword">end</span>
0175             <span class="keyword">end</span>
0176         <span class="keyword">end</span>
0177 
0178         <a name="_sub6" href="#_subfunctions" class="code">function sp = imag(sp)</a>
0179         <span class="comment">% Imaginary part of the coefficients of a symbolic polynomial.</span>
0180         <span class="comment">%</span>
0181         <span class="comment">% See also: imag</span>
0182 
0183             <span class="keyword">if</span> isscalar(sp)
0184                 sp.Coefficients = <a href="#_sub7" class="code" title="subfunction sp = imag(sp)">imag</a>(sp.Coefficients);
0185             <span class="keyword">else</span>
0186                 <span class="keyword">for</span> k = 1 : numel(sp)
0187                     sp(k).Coefficients = <a href="#_sub7" class="code" title="subfunction sp = imag(sp)">imag</a>(sp(k).Coefficients);
0188                 <span class="keyword">end</span>
0189             <span class="keyword">end</span>
0190         <span class="keyword">end</span>
0191 
0192         <a name="_sub7" href="#_subfunctions" class="code">function d = double(sp)</a>
0193         <span class="comment">% Convert a constant symbolic polynomial array to a double.</span>
0194         <span class="comment">%</span>
0195         <span class="comment">% See also: double</span>
0196 
0197             <span class="keyword">if</span> isscalar(sp)
0198                 assert(isempty(sp.Variables), <span class="keyword">...</span>
0199                     <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
0200                     <span class="string">'The symbolic polynomial is not a constant, cannot cast to double.'</span>);
0201 
0202                 d = sp.ConstantValue;
0203             <span class="keyword">else</span>
0204                 d = zeros(size(sp));
0205                 <span class="keyword">for</span> k = 1 : numel(sp)
0206                     d(k) = sp(k).ConstantValue;
0207                 <span class="keyword">end</span>
0208             <span class="keyword">end</span>
0209         <span class="keyword">end</span>
0210 
0211         <a name="_sub8" href="#_subfunctions" class="code">function sp = uplus(sp)</a>
0212         <span class="comment">% Unary plus for symbolic polynomial.</span>
0213         <span class="keyword">end</span>
0214 
0215         <a name="_sub9" href="#_subfunctions" class="code">function sp = uminus(sp)</a>
0216         <span class="comment">% Unary minus for symbolic polynomial.</span>
0217 
0218             <span class="keyword">if</span> isscalar(sp)
0219                 sp.Coefficients = -sp.Coefficients;
0220                 sp.ConstantValue = -sp.ConstantValue;
0221             <span class="keyword">else</span>
0222                 <span class="keyword">for</span> k = 1 : numel(sp)
0223                     sp(k).Coefficients = -sp(k).Coefficients;
0224                     sp(k).ConstantValue = -sp(k).ConstantValue;
0225                 <span class="keyword">end</span>
0226             <span class="keyword">end</span>
0227         <span class="keyword">end</span>
0228 
0229         <a name="_sub10" href="#_subfunctions" class="code">function sp = plus(sp1, sp2)</a>
0230         <span class="comment">% Addition for symbolic polynomials.</span>
0231         <span class="comment">%</span>
0232         <span class="comment">% Input arguments:</span>
0233         <span class="comment">% sp1, sp2:</span>
0234         <span class="comment">%    a symbolic polynomial or a numeric array</span>
0235 
0236             <span class="keyword">if</span> isa(sp1, <span class="string">'sympoly'</span>)
0237                 sp = <a href="#_sub70" class="code" title="subfunction res = add(lhs, rhs)">add</a>(sp1, sp2);
0238             <span class="keyword">else</span>
0239                 sp = <a href="#_sub70" class="code" title="subfunction res = add(lhs, rhs)">add</a>(sp2, sp1);
0240             <span class="keyword">end</span>
0241         <span class="keyword">end</span>
0242 
0243         <a name="_sub11" href="#_subfunctions" class="code">function sp = minus(sp1, sp2)</a>
0244         <span class="comment">% Subtraction for symbolic polynomials.</span>
0245         <span class="comment">%</span>
0246         <span class="comment">% Input arguments:</span>
0247         <span class="comment">% sp1, sp2:</span>
0248         <span class="comment">%    a symbolic polynomial or a numeric array</span>
0249 
0250             sp = sp1 + (-sp2);
0251         <span class="keyword">end</span>
0252 
0253         <a name="_sub12" href="#_subfunctions" class="code">function sp = times(sp1,sp2)</a>
0254         <span class="comment">% Elementwise multiplication for symbolic polynomials.</span>
0255         <span class="comment">%</span>
0256         <span class="comment">% Input arguments:</span>
0257         <span class="comment">% sp1, sp2:</span>
0258         <span class="comment">%    a symbolic polynomial or a numeric array</span>
0259 
0260             <span class="keyword">if</span> isa(sp1, <span class="string">'sympoly'</span>)
0261                 sp = <a href="#_sub71" class="code" title="subfunction res = multiply(lhs, rhs)">multiply</a>(sp1, sp2);
0262             <span class="keyword">else</span>
0263                 sp = <a href="#_sub71" class="code" title="subfunction res = multiply(lhs, rhs)">multiply</a>(sp2, sp1);
0264             <span class="keyword">end</span>
0265         <span class="keyword">end</span>
0266 
0267         <a name="_sub13" href="#_subfunctions" class="code">function sp = mtimes(sp1,sp2)</a>
0268         <span class="comment">% Elementwise multiplication for symbolic polynomials.</span>
0269         <span class="comment">%</span>
0270         <span class="comment">% Input arguments:</span>
0271         <span class="comment">% sp1, sp2:</span>
0272         <span class="comment">%    a symbolic polynomial or a numeric array of compatible size</span>
0273 
0274             <span class="comment">% matrix multiplication is only defined for scalars, vectors and matrices</span>
0275             validateattributes(sp1, {<span class="string">'sympoly'</span>,<span class="string">'numeric'</span>}, {<span class="string">'2d'</span>}, 1);
0276             validateattributes(sp2, {<span class="string">'sympoly'</span>,<span class="string">'numeric'</span>}, {<span class="string">'2d'</span>}, 2);
0277 
0278             s1 = numel(sp1);
0279             s2 = numel(sp2);
0280             <span class="keyword">if</span> s1 == 1 || s2 == 1  <span class="comment">% one or both are scalars</span>
0281                 sp = sp1 .* sp2;
0282             <span class="keyword">else</span>  <span class="comment">% both are arrays</span>
0283                 [m1,n1] = size(sp1);
0284                 [m2,n2] = size(sp2);
0285                 assert(n1 == m2, <span class="keyword">...</span>
0286                     <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
0287                     <span class="string">'Matrix multiplication requires compatible matrix sizes.'</span>);
0288 
0289                 sp = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(m1,n2));
0290                 <span class="keyword">for</span> i = 1 : m1
0291                     <span class="keyword">for</span> j = 1 : n2
0292                         lhs = sp1(i,:);
0293                         rhs = sp2(:,j);
0294                         lhs = lhs(:);
0295                         sp(i,j) = <a href="#_sub25" class="code" title="subfunction sump = sum(sp, varargin)">sum</a>(lhs .* rhs);
0296                     <span class="keyword">end</span>
0297                 <span class="keyword">end</span>
0298             <span class="keyword">end</span>
0299         <span class="keyword">end</span>
0300 
0301         <a name="_sub14" href="#_subfunctions" class="code">function sp = rdivide(sp1, sp2)</a>
0302         <span class="comment">% Elementwise (right) division for symbolic polynomials.</span>
0303         <span class="comment">%</span>
0304         <span class="comment">% Input arguments:</span>
0305         <span class="comment">% sp1, sp2:</span>
0306         <span class="comment">%    a symbolic polynomial or numeric array</span>
0307 
0308             <span class="keyword">if</span> isnumeric(sp2)
0309                 validateattributes(sp1, {<span class="string">'sympoly'</span>}, {<span class="string">'2d'</span>}, 1);
0310                 validateattributes(sp2, {<span class="string">'numeric'</span>}, {<span class="string">'2d'</span>}, 2);
0311 
0312                 <span class="keyword">if</span> isscalar(sp1) &amp;&amp; isscalar(sp2)
0313                     sp = sp1;
0314                     sp.Coefficients = sp.Coefficients ./ sp2;
0315                     sp.ConstantValue = sp.ConstantValue ./ sp2;
0316                 <span class="keyword">elseif</span> isscalar(sp2)
0317                     sp = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp1)));
0318                     <span class="keyword">for</span> k = 1 : numel(sp)
0319                         sp(k) = sp1(k);
0320                         sp(k).Coefficients = sp(k).Coefficients ./ sp2;
0321                         sp(k).ConstantValue = sp(k).ConstantValue ./ sp2;
0322                     <span class="keyword">end</span>
0323                 <span class="keyword">elseif</span> isscalar(sp1)
0324                     sp = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp2)));
0325                     <span class="keyword">for</span> k = 1 : numel(sp)
0326                         sp(k) = sp1;
0327                         sp(k).Coefficients = sp(k).Coefficients ./ sp2(k);
0328                         sp(k).ConstantValue = sp(k).ConstantValue ./ sp2(k);
0329                     <span class="keyword">end</span>
0330                 <span class="keyword">else</span>
0331                     assert(all(size(sp1) == size(sp2)), <span class="keyword">...</span><span class="comment">  % verify if they are compatible in size</span>
0332                         <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
0333                         <span class="string">'Division of symbolic polynomial array and numeric array of incompatible size.'</span>);
0334 
0335                     sp = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp1)));
0336                     <span class="keyword">for</span> k = 1 : numel(sp)
0337                         sp(k) = sp1(k);
0338                         sp(k).Coefficients = sp(k).Coefficients ./ sp2(k);
0339                         sp(k).ConstantValue = sp(k).ConstantValue ./ sp2(k);
0340                     <span class="keyword">end</span>
0341                 <span class="keyword">end</span>
0342             <span class="keyword">elseif</span> isnumeric(sp1)
0343                 sp = <a href="sympoly.html" class="code" title="">sympoly</a>(sp1) ./ sp2;
0344             <span class="keyword">else</span>
0345                 validateattributes(sp1, {<span class="string">'sympoly'</span>}, {<span class="string">'2d'</span>}, 1);
0346                 validateattributes(sp2, {<span class="string">'sympoly'</span>}, {<span class="string">'2d'</span>}, 2);
0347 
0348                 <span class="keyword">if</span> isscalar(sp1) &amp;&amp; isscalar(sp2)
0349                     sp = <a href="#_sub72" class="code" title="subfunction sp = scalardivide(sp1, sp2)">scalardivide</a>(sp1, sp2);
0350                 <span class="keyword">elseif</span> isscalar(sp2)
0351                     sp = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp1)));
0352                     <span class="keyword">for</span> k = 1 : numel(sp)
0353                         sp(k) = <a href="#_sub72" class="code" title="subfunction sp = scalardivide(sp1, sp2)">scalardivide</a>(sp1(k), sp2);
0354                     <span class="keyword">end</span>
0355                 <span class="keyword">elseif</span> isscalar(sp1)
0356                     sp = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp2)));
0357                     <span class="keyword">for</span> k = 1 : numel(sp)
0358                         sp(k) = <a href="#_sub72" class="code" title="subfunction sp = scalardivide(sp1, sp2)">scalardivide</a>(sp1, sp2(k));
0359                     <span class="keyword">end</span>
0360                 <span class="keyword">else</span>
0361                     assert(all(size(sp1) == size(sp2)), <span class="keyword">...</span><span class="comment">  % verify if they are compatible in size</span>
0362                         <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
0363                         <span class="string">'Synthetic division of symbolic polynomial arrays of incompatible size.'</span>);
0364 
0365                     sp = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp1)));
0366                     <span class="keyword">for</span> k = 1 : numel(sp)
0367                         sp(k) = <a href="#_sub72" class="code" title="subfunction sp = scalardivide(sp1, sp2)">scalardivide</a>(sp1(k), sp2(k));
0368                     <span class="keyword">end</span>
0369                 <span class="keyword">end</span>
0370             <span class="keyword">end</span>
0371         <span class="keyword">end</span>
0372 
0373         <a name="_sub15" href="#_subfunctions" class="code">function sp = mrdivide(sp1,sp2)</a>
0374         <span class="comment">% Matrix (right) division for symbolic polynomials.</span>
0375         <span class="comment">%</span>
0376         <span class="comment">% Input arguments:</span>
0377         <span class="comment">% sp1, sp2:</span>
0378         <span class="comment">%    a symbolic polynomial or numeric array</span>
0379 
0380             validateattributes(sp1, {<span class="string">'sympoly'</span>,<span class="string">'numeric'</span>}, {<span class="string">'2d'</span>}, 1);
0381             validateattributes(sp2, {<span class="string">'sympoly'</span>,<span class="string">'numeric'</span>}, {<span class="string">'2d'</span>}, 2);
0382 
0383             <span class="keyword">if</span> isscalar(sp1) || isscalar(sp2)  <span class="comment">% one or both are scalars</span>
0384                 sp = sp1 ./ sp2;
0385             <span class="keyword">else</span>
0386                 error(<span class="string">'math:sympoly:NotSupported'</span>, <span class="string">'General matrix division is not supported on symbolic polynomials.'</span>);
0387             <span class="keyword">end</span>
0388         <span class="keyword">end</span>
0389 
0390         <a name="_sub16" href="#_subfunctions" class="code">function sp = ldivide(sp1, sp2)</a>
0391         <span class="comment">% Elementwise (left) division for symbolic polynomials.</span>
0392         <span class="comment">%</span>
0393         <span class="comment">% Input arguments:</span>
0394         <span class="comment">% sp1, sp2:</span>
0395         <span class="comment">%    a symbolic polynomial or numeric array</span>
0396 
0397             sp = sp2 ./ sp1;
0398         <span class="keyword">end</span>
0399 
0400         <a name="_sub17" href="#_subfunctions" class="code">function sp = mldivide(sp1, sp2)</a>
0401         <span class="comment">% Matrix (left) division for symbolic polynomials.</span>
0402         <span class="comment">%</span>
0403         <span class="comment">% Input arguments:</span>
0404         <span class="comment">% sp1, sp2:</span>
0405         <span class="comment">%    a symbolic polynomial or numeric array</span>
0406 
0407             sp = sp2 / sp1;
0408         <span class="keyword">end</span>
0409 
0410         <a name="_sub18" href="#_subfunctions" class="code">function [q,r,rflag] = quorem(sp1, sp2)</a>
0411         <span class="comment">% Polynomial division with remainder.</span>
0412         <span class="comment">%</span>
0413         <span class="comment">% Output arguments:</span>
0414         <span class="comment">% q:</span>
0415         <span class="comment">%    quotient symbolic polynomial array of size max(size(sp1),size(sp2))</span>
0416         <span class="comment">% r:</span>
0417         <span class="comment">%    remainder symbolic polynomial array of size max(size(sp1),size(sp2))</span>
0418         <span class="comment">% rflag:</span>
0419         <span class="comment">%    logical array of whether the synthetic division produced a remainder</span>
0420 
0421             validateattributes(sp1, {<span class="string">'sympoly'</span>}, {<span class="string">'2d'</span>}, 1);
0422             validateattributes(sp2, {<span class="string">'sympoly'</span>}, {<span class="string">'2d'</span>}, 2);
0423 
0424             <span class="keyword">if</span> isscalar(sp1) &amp;&amp; isscalar(sp2)
0425                 [q,r,rflag] = <a href="#_sub73" class="code" title="subfunction [q,r,rflag] = longdivide(lhs, rhs)">longdivide</a>(sp1, sp2);
0426             <span class="keyword">elseif</span> isscalar(sp2)
0427                 q = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp1)));
0428                 r = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp1)));
0429                 rflag = false(size(sp1));
0430                 <span class="keyword">for</span> k = 1 : numel(q)
0431                     [q(k),r(k),rflag(k)] = <a href="#_sub73" class="code" title="subfunction [q,r,rflag] = longdivide(lhs, rhs)">longdivide</a>(sp1(k), sp2);
0432                 <span class="keyword">end</span>
0433             <span class="keyword">elseif</span> isscalar(sp1)
0434                 q = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp2)));
0435                 r = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp2)));
0436                 rflag = false(size(sp2));
0437                 <span class="keyword">for</span> k = 1 : numel(q)
0438                     [q(k),r(k),rflag(k)] = <a href="#_sub73" class="code" title="subfunction [q,r,rflag] = longdivide(lhs, rhs)">longdivide</a>(sp1, sp2(k));
0439                 <span class="keyword">end</span>
0440             <span class="keyword">else</span>
0441                 assert(all(size(sp1) == size(sp2)), <span class="keyword">...</span><span class="comment">  % verify if they are compatible in size</span>
0442                     <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
0443                     <span class="string">'Synthetic division of symbolic polynomial arrays of incompatible size.'</span>);
0444 
0445                 q = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp1)));
0446                 r = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sp1)));
0447                 rflag = false(size(sp1));
0448                 <span class="keyword">for</span> k = 1 : numel(q)
0449                     [q(k),r(k),rflag(k)] = <a href="#_sub73" class="code" title="subfunction [q,r,rflag] = longdivide(lhs, rhs)">longdivide</a>(sp1(k), sp2(k));
0450                 <span class="keyword">end</span>
0451             <span class="keyword">end</span>
0452         <span class="keyword">end</span>
0453 
0454         <a name="_sub19" href="#_subfunctions" class="code">function [q,r,rflag] = syndivide(sp1, sp2)</a>
0455         <span class="comment">% Compatibility method.</span>
0456         <span class="comment">%</span>
0457         <span class="comment">% See also: sympoly.quorem</span>
0458 
0459             [q,r,rflag] = <a href="#_sub19" class="code" title="subfunction [q,r,rflag] = quorem(sp1, sp2)">quorem</a>(sp1, sp2);
0460         <span class="keyword">end</span>
0461 
0462         <a name="_sub20" href="#_subfunctions" class="code">function sp = power(sp,n)</a>
0463         <span class="comment">% Raise a symbolic polynomial (elementwise) to a scalar power.</span>
0464         <span class="comment">%</span>
0465         <span class="comment">% If n is a non-negative integer scalar, the power is computed by</span>
0466         <span class="comment">% repeated multiplications. If n is fractional, the symbolic</span>
0467         <span class="comment">% polynomial should be single-term. Constant symbolic polynomials can be</span>
0468         <span class="comment">% raised to any power.</span>
0469 
0470             validateattributes(sp, {<span class="string">'sympoly'</span>}, {});
0471             validateattributes(n, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>,<span class="string">'scalar'</span>});
0472 
0473             <span class="comment">% for an array, raise the individual elements to the n-th power</span>
0474             k = numel(sp);
0475             <span class="keyword">if</span> isscalar(sp)  <span class="comment">% a scalar symbolic polynomial</span>
0476                 <span class="keyword">if</span> n == 0  <span class="comment">% the zero-th power is 1</span>
0477                     sp = <a href="sympoly.html" class="code" title="">sympoly</a>(1);
0478                 <span class="keyword">elseif</span> n == 1
0479                     <span class="comment">% no-op</span>
0480                 <span class="keyword">elseif</span> <a href="#_sub29" class="code" title="subfunction tf = isconstant(sp)">isconstant</a>(sp)  <span class="comment">% e.g. sympoly(2)^5</span>
0481                     sp.ConstantValue = sp.ConstantValue.^n;
0482                 <span class="keyword">elseif</span> <a href="#_sub6" class="code" title="subfunction sp = real(sp)">real</a>(n) &amp;&amp; n == floor(n) &amp;&amp; n &gt; 0 &amp;&amp; ~<a href="#_sub32" class="code" title="subfunction tf = ismonomial(sp)">ismonomial</a>(sp)  <span class="comment">% a positive integer exponent and multiple terms, use multiplication</span>
0483                     sp1 = sp;
0484                     k = 1;
0485                     <span class="keyword">while</span> (2*k) &lt;= n  <span class="comment">% square until near k</span>
0486                         sp = sp.*sp;
0487                         k = 2*k;
0488                     <span class="keyword">end</span>
0489 
0490                     <span class="keyword">if</span> k &lt; n
0491                         <span class="keyword">for</span> i = (k+1):n
0492                             sp = sp.*sp1;
0493                         <span class="keyword">end</span>
0494                     <span class="keyword">end</span>
0495                 <span class="keyword">else</span>  <span class="comment">% a fractional or negative exponent can only be applied to a single term</span>
0496                     assert(<a href="#_sub34" class="code" title="subfunction tf = issingleterm(sp)">issingleterm</a>(sp), <span class="keyword">...</span>
0497                         <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
0498                         <span class="string">'Fractional or negative power requires a polynomial of a single term.'</span>);
0499 
0500                     <span class="comment">% raise a single term to the n-th power</span>
0501                     sp.Coefficients = sp.Coefficients.^n;
0502                     sp.Exponents = sp.Exponents.*n;
0503                 <span class="keyword">end</span>
0504             <span class="keyword">else</span>  <span class="comment">% an array; raise each element to the n-th power</span>
0505                 <span class="keyword">for</span> i = 1:k
0506                     sp(i) = sp(i).^n;
0507                 <span class="keyword">end</span>
0508             <span class="keyword">end</span>
0509         <span class="keyword">end</span>
0510 
0511         <a name="_sub21" href="#_subfunctions" class="code">function sp = mpower(sp,n)</a>
0512         <span class="comment">% Raise a scalar or matrix symbolic polynomial to a scalar power.</span>
0513 
0514             validateattributes(sp, {<span class="string">'sympoly'</span>}, {});
0515             validateattributes(n, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>,<span class="string">'scalar'</span>});
0516 
0517             <span class="keyword">if</span> n == 0
0518                 sp = <a href="sympoly.html" class="code" title="">sympoly</a>(eye(size(sp)));
0519             <span class="keyword">elseif</span> n == 1  <span class="comment">% unit power</span>
0520                 <span class="comment">% no-op</span>
0521             <span class="keyword">elseif</span> isscalar(sp)  <span class="comment">% matrix power and elementwise power are equivalent</span>
0522                 sp = sp .^ n;
0523             <span class="keyword">elseif</span> <a href="#_sub29" class="code" title="subfunction tf = isconstant(sp)">isconstant</a>(sp)
0524                 sp = <a href="sympoly.html" class="code" title="">sympoly</a>(<a href="#_sub8" class="code" title="subfunction d = double(sp)">double</a>(sp) ^ n);
0525             <span class="keyword">else</span>  <span class="comment">% symbolic polynomial array, must be square, and n must be a non-negative integer</span>
0526                 validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'2d'</span>,<span class="string">'size'</span>,[size(sp,1),size(sp,1)]});  <span class="comment">% ensure it is square</span>
0527                 validateattributes(n, {<span class="string">'numeric'</span>}, {<span class="string">'positive'</span>,<span class="string">'integer'</span>});  <span class="comment">% integer power &gt; 1</span>
0528 
0529                 sp1 = sp;
0530 
0531                 k = 1;
0532                 <span class="keyword">while</span> k &lt; n  <span class="comment">% repeated squaring until close enough</span>
0533                     <span class="keyword">if</span> 2*k &lt;= n
0534                         sp = sp*sp;
0535                         k = 2*k;
0536                     <span class="keyword">else</span>
0537                         sp = sp*sp1;
0538                         k = k+1;
0539                     <span class="keyword">end</span>
0540                 <span class="keyword">end</span>
0541             <span class="keyword">end</span>
0542         <span class="keyword">end</span>
0543 
0544         <a name="_sub22" href="#_subfunctions" class="code">function spd = diag(sp)</a>
0545         <span class="comment">% Diagonal of square matrix or diagonal matrix from vector.</span>
0546         <span class="comment">%</span>
0547         <span class="comment">% Input arguments:</span>
0548         <span class="comment">% sp:</span>
0549         <span class="comment">%    a matrix of symbolic polynomials for diagonal extraction, or</span>
0550         <span class="comment">%    a vector of symbolic polynomials for diagonal matrix</span>
0551         <span class="comment">%    construction</span>
0552         <span class="comment">%</span>
0553         <span class="comment">% Examples:</span>
0554         <span class="comment">% &gt;&gt; diag(sympoly(eye(3,3))) % returns [ 1 1 1 ]</span>
0555         <span class="comment">% &gt;&gt; diag(sympoly(eye(2,3))) % returns [ 1 1 ]</span>
0556         <span class="comment">% &gt;&gt; sympolys x y;</span>
0557         <span class="comment">% &gt;&gt; diag([x y])             % returns [ x 0 ; 0 y ]</span>
0558         <span class="comment">%</span>
0559         <span class="comment">% See also: diag</span>
0560 
0561             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'2d'</span>,<span class="string">'nonempty'</span>});
0562 
0563             [m,n] = size(sp);
0564             <span class="keyword">if</span> m == 1 || n == 1  <span class="comment">% sp is a vector, build a diagonal matrix from it</span>
0565                 l = numel(sp);
0566                 spd = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(l,l));
0567                 spd(1 + (0:l-1)*(l+1)) = sp(:);
0568             <span class="keyword">else</span>  <span class="comment">% sp is a 2d matrix, extract the main diagonal</span>
0569                 p = min(m,n);
0570                 spd = sp(1 + (0:p-1)*(m+1));
0571             <span class="keyword">end</span>
0572         <span class="keyword">end</span>
0573 
0574         <a name="_sub23" href="#_subfunctions" class="code">function prodp = prod(sp, varargin)</a>
0575         <span class="comment">% Product of a symbolic polynomial array along a given dimension.</span>
0576         <span class="comment">%</span>
0577         <span class="comment">% Input arguments:</span>
0578         <span class="comment">% dim:</span>
0579         <span class="comment">%    a dimension to sum over, defaults to 1 (for any shape except</span>
0580         <span class="comment">%    row vector) or 2 (for row vector)</span>
0581         <span class="comment">%</span>
0582         <span class="comment">% See also: prod</span>
0583 
0584             dim = <a href="#_sub84" class="code" title="subfunction dim = operatingdimension(sp, dim)">operatingdimension</a>(sp, varargin{:});
0585             np = ndims(sp);
0586             s = size(sp);
0587 
0588             <span class="keyword">switch</span> np
0589                 <span class="keyword">case</span> 2
0590                     <span class="keyword">switch</span> dim
0591                         <span class="keyword">case</span> 1  <span class="comment">% a row vector of product of rows</span>
0592                             prodp = <a href="sympoly.html" class="code" title="">sympoly</a>(ones(1, s(2)));
0593                             <span class="keyword">for</span> k = 1 : s(1)  <span class="comment">% enumerate rows</span>
0594                                 prodp = prodp .* sp(k,:);
0595                             <span class="keyword">end</span>
0596                         <span class="keyword">case</span> 2  <span class="comment">% a column vector of product of columns</span>
0597                             prodp = <a href="sympoly.html" class="code" title="">sympoly</a>(ones(s(1), 1));
0598                             <span class="keyword">for</span> k = 1 : s(2)  <span class="comment">% enumerate columns</span>
0599                                 prodp = prodp .* sp(:,k);
0600                             <span class="keyword">end</span>
0601                     <span class="keyword">end</span>
0602                 <span class="keyword">otherwise</span>  <span class="comment">% an n-dimensional array</span>
0603                     ss = s;       <span class="comment">% dimensions of original object</span>
0604                     ss(dim) = 1;  <span class="comment">% dimension to take product over</span>
0605 
0606                     si = cell(1,np);
0607                     <span class="keyword">for</span> i = 1:np
0608                         si{i} = 1:s(i);
0609                     <span class="keyword">end</span>
0610 
0611                     <span class="keyword">if</span> any(ss~=1)  <span class="comment">% has non-singleton dimension</span>
0612                         prodp = repmat(<a href="sympoly.html" class="code" title="">sympoly</a>(1),ss);
0613                     <span class="keyword">else</span>
0614                         prodp = <a href="sympoly.html" class="code" title="">sympoly</a>(1);
0615                     <span class="keyword">end</span>
0616                     <span class="keyword">for</span> i = 1 : s(dim)
0617                         si{dim} = i;
0618                         prodp = prodp .* sp(si{:});
0619                     <span class="keyword">end</span>
0620             <span class="keyword">end</span>
0621         <span class="keyword">end</span>
0622 
0623         <a name="_sub24" href="#_subfunctions" class="code">function sump = sum(sp, varargin)</a>
0624         <span class="comment">% Sum a symbolic polynomial array along a given dimension.</span>
0625         <span class="comment">%</span>
0626         <span class="comment">% Input arguments:</span>
0627         <span class="comment">% dim:</span>
0628         <span class="comment">%    a dimension to sum over, defaults to 1 (for any shape except</span>
0629         <span class="comment">%    row vector) or 2 (for row vector)</span>
0630         <span class="comment">%</span>
0631         <span class="comment">% See also: sum</span>
0632 
0633             dim = <a href="#_sub84" class="code" title="subfunction dim = operatingdimension(sp, dim)">operatingdimension</a>(sp, varargin{:});
0634             np = ndims(sp);
0635             s = size(sp);
0636 
0637             <span class="keyword">switch</span> np
0638                 <span class="keyword">case</span> 2
0639                     <span class="keyword">switch</span> dim
0640                         <span class="keyword">case</span> 1  <span class="comment">% sum down rows</span>
0641                             sump = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(1, s(2)));
0642                             <span class="keyword">for</span> k = 1 : s(1)  <span class="comment">% enumerate rows</span>
0643                                 sump = sump + sp(k,:);
0644                             <span class="keyword">end</span>
0645                         <span class="keyword">case</span> 2  <span class="comment">% sum across columns</span>
0646                             sump = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(s(1), 1));
0647                             <span class="keyword">for</span> k = 1 : s(2)  <span class="comment">% enumerate columns</span>
0648                                 sump = sump + sp(:,k);
0649                             <span class="keyword">end</span>
0650                     <span class="keyword">end</span>
0651                 <span class="keyword">otherwise</span>  <span class="comment">% an n-dimensional array</span>
0652                     ss = s;        <span class="comment">% e.g. [2 6 3 6]</span>
0653                     ss(dim) = 1;   <span class="comment">% e.g. [2 6 1 6] with dim = 3</span>
0654 
0655                     si = cell(1,np);  <span class="comment">% indexer cell array</span>
0656                     <span class="keyword">for</span> i = 1:np
0657                         si{i} = 1 : s(i);  <span class="comment">% e.g. {1:2 1:6 1:3 1:6}</span>
0658                     <span class="keyword">end</span>
0659 
0660                     <span class="keyword">if</span> any(ss~=1)  <span class="comment">% has non-singleton dimension</span>
0661                         sump = repmat(<a href="sympoly.html" class="code" title="">sympoly</a>(0),ss);
0662                     <span class="keyword">else</span>
0663                         sump = <a href="sympoly.html" class="code" title="">sympoly</a>(0);
0664                     <span class="keyword">end</span>
0665                     <span class="keyword">for</span> i = 1 : s(dim)  <span class="comment">% e.g. 1:3</span>
0666                         si{dim} = i;    <span class="comment">% e.g. {1:2 1:6 i 1:6}</span>
0667                         sump = sump + sp(si{:});
0668                     <span class="keyword">end</span>
0669             <span class="keyword">end</span>
0670         <span class="keyword">end</span>
0671 
0672         <a name="_sub25" href="#_subfunctions" class="code">function sp = modexpon(sp, p)</a>
0673         <span class="comment">% Reduce the exponents of a symbolic polynomial to modulo p.</span>
0674         <span class="comment">%</span>
0675         <span class="comment">% p:</span>
0676         <span class="comment">%    a positive integer</span>
0677         <span class="comment">%</span>
0678         <span class="comment">% See also: mod, rem</span>
0679 
0680             validateattributes(p, {<span class="string">'numeric'</span>}, {<span class="string">'integer'</span>,<span class="string">'scalar'</span>});
0681 
0682             <span class="keyword">for</span> k = 1 : numel(sp)
0683                 sp(k).Exponents = mod(sp(k).Exponents, p);
0684                 cp = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(cp);
0685             <span class="keyword">end</span>
0686         <span class="keyword">end</span>
0687 
0688         <a name="_sub26" href="#_subfunctions" class="code">function sp = sqrt(sp)</a>
0689             assert(<a href="#_sub29" class="code" title="subfunction tf = isconstant(sp)">isconstant</a>(sp) || <a href="#_sub32" class="code" title="subfunction tf = ismonomial(sp)">ismonomial</a>(sp), <span class="keyword">...</span>
0690                 <span class="string">'math:sympoly:NotSupported'</span>, <span class="keyword">...</span>
0691                 <span class="string">'Square root of symbolic polynomial with multiple terms is not supported.'</span>);
0692 
0693             <span class="keyword">if</span> <a href="#_sub29" class="code" title="subfunction tf = isconstant(sp)">isconstant</a>(sp)
0694                 sp.ConstantValue = <a href="#_sub27" class="code" title="subfunction sp = sqrt(sp)">sqrt</a>(sp.ConstantValue);
0695             <span class="keyword">elseif</span> <a href="#_sub32" class="code" title="subfunction tf = ismonomial(sp)">ismonomial</a>(sp)
0696                 sp.Exponents = sp.Exponents / 2;
0697                 sp.Coefficients = <a href="#_sub27" class="code" title="subfunction sp = sqrt(sp)">sqrt</a>(sp.Coefficients);
0698             <span class="keyword">end</span>
0699         <span class="keyword">end</span>
0700 
0701         <a name="_sub27" href="#_subfunctions" class="code">function vars = variables(sp)</a>
0702         <span class="comment">% All variables the symbolic polynomial is a function of.</span>
0703         <span class="comment">%</span>
0704         <span class="comment">% Output arguments:</span>
0705         <span class="comment">% vars:</span>
0706         <span class="comment">%    a cell array of strings or a vector of symvariable objects, depending</span>
0707         <span class="comment">%    on the type of variables in the symbolic polynomial array</span>
0708 
0709             <span class="keyword">if</span> isscalar(sp)
0710                 vars = sp.Variables;
0711             <span class="keyword">else</span>
0712                 vars = sp(1).Variables;
0713                 <span class="keyword">for</span> k = 2 : numel(sp)
0714                     vars = union(vars, sp(k).Variables);
0715                 <span class="keyword">end</span>
0716             <span class="keyword">end</span>
0717         <span class="keyword">end</span>
0718 
0719         <a name="_sub28" href="#_subfunctions" class="code">function tf = isconstant(sp)</a>
0720         <span class="comment">% Whether the polynomial or array of polynomials comprises of constant terms.</span>
0721         <span class="comment">%</span>
0722         <span class="comment">% Examples:</span>
0723         <span class="comment">% &gt;&gt; x = sympoly('x');</span>
0724         <span class="comment">% &gt;&gt; isconstant(sympoly(2)) % returns true</span>
0725         <span class="comment">% &gt;&gt; isconstant(sympoly(0)) % returns true</span>
0726         <span class="comment">% &gt;&gt; isconstant(x)          % returns false</span>
0727 
0728             <span class="keyword">if</span> isscalar(sp)
0729                 tf = isempty(sp.Variables);  <span class="comment">% has no variables</span>
0730             <span class="keyword">else</span>
0731                 tf = true;
0732                 <span class="keyword">for</span> k = 1 : numel(sp)
0733                     <span class="keyword">if</span> ~isempty(sp(k).Variables)
0734                         tf = false;
0735                         <span class="keyword">return</span>;
0736                     <span class="keyword">end</span>
0737                 <span class="keyword">end</span>
0738             <span class="keyword">end</span>
0739         <span class="keyword">end</span>
0740 
0741         <a name="_sub29" href="#_subfunctions" class="code">function tf = islinear(sp)</a>
0742         <span class="comment">% Whether at most linear terms comprise the polynomial or array of polynomials.</span>
0743         <span class="comment">%</span>
0744         <span class="comment">% Examples:</span>
0745         <span class="comment">% &gt;&gt; sympoly x y z;</span>
0746         <span class="comment">% &gt;&gt; islinear(x)          % returns true</span>
0747         <span class="comment">% &gt;&gt; islinear(x+y)        % returns true</span>
0748         <span class="comment">% &gt;&gt; islinear(x+1)        % returns true</span>
0749         <span class="comment">% &gt;&gt; islinear(sympoly(2)) % returns true</span>
0750         <span class="comment">% &gt;&gt; islinear(x^2)        % returns false</span>
0751         <span class="comment">% &gt;&gt; islinear(x^-2)       % returns false</span>
0752 
0753             <span class="keyword">if</span> isscalar(sp)
0754                 tf = all(all(sp.Exponents &gt;= 0 &amp; sp.Exponents &lt;= 1));
0755             <span class="keyword">else</span>
0756                 tf = true;
0757                 <span class="keyword">for</span> k = 1 : numel(sp)
0758                     <span class="keyword">if</span> any(any(sp.Exponents &lt; 0 | sp.Exponents &gt; 1))
0759                         tf = false;
0760                         <span class="keyword">return</span>;
0761                     <span class="keyword">end</span>
0762                 <span class="keyword">end</span>
0763             <span class="keyword">end</span>
0764         <span class="keyword">end</span>
0765 
0766         <a name="_sub30" href="#_subfunctions" class="code">function tf = isunivariate(sp)</a>
0767         <span class="comment">% Whether the symbolic polynomial or array of polynomials is univariate.</span>
0768         <span class="comment">% Univariate polynomials are a function of a single variable.</span>
0769         <span class="comment">%</span>
0770         <span class="comment">% See also: poly</span>
0771 
0772             <span class="keyword">if</span> isscalar(sp)
0773                 tf = numel(sp.Variables) == 1;  <span class="comment">% cannot determine variable of zero-degree polynomial</span>
0774             <span class="keyword">elseif</span> ~isempty(sp)
0775                 <span class="keyword">for</span> k = 1 : numel(sp)
0776                     <span class="keyword">if</span> numel(sp(k).Variables) &gt;= 2  <span class="comment">% one of the array entries is not univariate</span>
0777                         tf = false;
0778                         <span class="keyword">return</span>;
0779                     <span class="keyword">end</span>
0780                 <span class="keyword">end</span>
0781 
0782                 vars = <a href="#_sub28" class="code" title="subfunction vars = variables(sp)">variables</a>(sp);
0783                 tf = numel(vars) == 1;
0784             <span class="keyword">else</span>  <span class="comment">% empty arrays are considered univariate</span>
0785                 tf = true;
0786             <span class="keyword">end</span>
0787         <span class="keyword">end</span>
0788 
0789         <a name="_sub31" href="#_subfunctions" class="code">function tf = ismonomial(sp)</a>
0790         <span class="comment">% Whether the symbolic polynomial represents a univariate monomial.</span>
0791         <span class="comment">%</span>
0792         <span class="comment">% Examples:</span>
0793         <span class="comment">% &gt;&gt; sympoly x y;</span>
0794         <span class="comment">% &gt;&gt; ismonomial(x^6)        % returns true</span>
0795         <span class="comment">% &gt;&gt; ismonomial(x*y)        % returns false</span>
0796         <span class="comment">% &gt;&gt; ismonomial(sympoly(2)) % returns false</span>
0797         <span class="comment">% &gt;&gt; ismonomial(x+y)        % returns false</span>
0798         <span class="comment">% &gt;&gt; ismonomial(2*x)        % returns true</span>
0799 
0800             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
0801 
0802             tf = numel(sp.Coefficients) == 1 <span class="keyword">...</span><span class="comment">  % single term</span>
0803                 &amp;&amp; numel(sp.Variables) == 1 <span class="keyword">...</span><span class="comment">   % of a single variable</span>
0804                 &amp;&amp; sp.ConstantValue == 0;         <span class="comment">% with no constant value</span>
0805         <span class="keyword">end</span>
0806 
0807         <a name="_sub32" href="#_subfunctions" class="code">function tf = issinglevariable(sp)</a>
0808         <span class="comment">% Whether the symbolic polynomial represents a single variable.</span>
0809 
0810             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
0811 
0812             tf = numel(sp.Coefficients) == 1 &amp;&amp; sp.Coefficients == 1 <span class="keyword">...</span><span class="comment">  % single term with unit coefficient</span>
0813                 &amp;&amp; numel(sp.Variables) == 1 <span class="keyword">...</span><span class="comment">                           % of a single variable</span>
0814                 &amp;&amp; sp.Exponents == 1 <span class="keyword">...</span><span class="comment">                                  % of degree one</span>
0815                 &amp;&amp; sp.ConstantValue == 0;                                 <span class="comment">% with no constant value</span>
0816         <span class="keyword">end</span>
0817 
0818         <a name="_sub33" href="#_subfunctions" class="code">function tf = issingleterm(sp)</a>
0819         <span class="comment">% Whether the symbolic polynomial represents a single term.</span>
0820         <span class="comment">% The term may have an exponent and a coefficient but cannot be</span>
0821         <span class="comment">% the constant term.</span>
0822 
0823             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
0824 
0825             tf = numel(sp.Coefficients) == 1 <span class="keyword">...</span><span class="comment">  % single term</span>
0826                 &amp;&amp; sp.ConstantValue == 0;         <span class="comment">% with no constant value</span>
0827         <span class="keyword">end</span>
0828 
0829         <a name="_sub34" href="#_subfunctions" class="code">function spd = det(sp)</a>
0830         <span class="comment">% Determinant of a symbolic polynomial array.</span>
0831         <span class="comment">%</span>
0832         <span class="comment">% Input arguments:</span>
0833         <span class="comment">% sp:</span>
0834         <span class="comment">%    a square matrix of symbolic polynomials</span>
0835         <span class="comment">%</span>
0836         <span class="comment">% Output arguments:</span>
0837         <span class="comment">% spd:</span>
0838         <span class="comment">%    a scalar symbolic polynomial</span>
0839         <span class="comment">%</span>
0840         <span class="comment">% See also: det</span>
0841 
0842             n = size(sp,1);
0843             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'2d'</span>,<span class="string">'size'</span>,[n,n]});
0844 
0845             <span class="keyword">switch</span> n
0846                 <span class="keyword">case</span> 1  <span class="comment">% 1 x 1</span>
0847                     spd = sp;
0848                 <span class="keyword">case</span> 2  <span class="comment">% 2 x 2</span>
0849                     spd = sp(1,1).*sp(2,2)-sp(1,2).*sp(2,1);
0850                 <span class="keyword">case</span> 3  <span class="comment">% 3 x 3</span>
0851                     spd = sp(1,1).*sp(2,2).*sp(3,3) + sp(1,2).*sp(2,3).*sp(3,1) <span class="keyword">...</span>
0852                         + sp(1,3).*sp(2,1).*sp(3,2) - sp(3,1).*sp(2,2).*sp(1,3) <span class="keyword">...</span>
0853                         - sp(3,2).*sp(2,3).*sp(1,1) - sp(3,3).*sp(2,1).*sp(1,2);
0854                 <span class="keyword">otherwise</span>  <span class="comment">% 4 x 4 and higher, use minors to compute the determinant recursively</span>
0855                     spd = 0;
0856                     minorsigns = 1;
0857                     <span class="keyword">for</span> i = 1 : n
0858                         j = [1:i-1, i+1:n];
0859                         spd = spd + minorsigns .* sp(i,1) .* <a href="#_sub35" class="code" title="subfunction spd = det(sp)">det</a>(sp(j,2:n));
0860                         minorsigns = -minorsigns;
0861                     <span class="keyword">end</span>
0862             <span class="keyword">end</span>
0863         <span class="keyword">end</span>
0864 
0865         <a name="_sub35" href="#_subfunctions" class="code">function di = defint(sp, varargin)</a>
0866         <span class="comment">% Definite integral of a symbolic polynomial.</span>
0867         <span class="comment">%</span>
0868         <span class="comment">% Input arguments:</span>
0869         <span class="comment">% intvar:</span>
0870         <span class="comment">%    name of variable to integrate over</span>
0871         <span class="comment">% from, to:</span>
0872         <span class="comment">%    limits of integration</span>
0873         <span class="comment">%</span>
0874         <span class="comment">% Output arguments:</span>
0875         <span class="comment">% di:</span>
0876         <span class="comment">%    definite integral of the polynomial</span>
0877         <span class="comment">%</span>
0878         <span class="comment">% See also: sympoly.int</span>
0879 
0880             error(nargchk(2, 4, nargin, <span class="string">'struct'</span>));
0881             <span class="keyword">switch</span> nargin
0882                 <span class="keyword">case</span> 2  <span class="comment">% defint(sp, [-1,1])</span>
0883                     intvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp);
0884                     arg = varargin{end};
0885                     validateattributes(arg, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>,<span class="string">'size'</span>,[1,2]});
0886                     from = arg(1);
0887                     to = arg(2);
0888                 <span class="keyword">case</span> 3
0889                     <span class="keyword">if</span> isnumeric(varargin{1})  <span class="comment">% defint(sp, -1, 1)</span>
0890                         intvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp);
0891                         from = varargin{1};
0892                         to = varargin{2};
0893                     <span class="keyword">else</span>  <span class="comment">% defint(sp, 'x', [-1,1])</span>
0894                         intvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{1});
0895                         arg = varargin{end};
0896                         validateattributes(arg, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>,<span class="string">'size'</span>,[1,2]});
0897                         from = arg(1);
0898                         to = arg(2);
0899                     <span class="keyword">end</span>
0900                 <span class="keyword">case</span> 4  <span class="comment">% defint(sp, 'x', -1, 1)</span>
0901                     intvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{1});
0902                     from = varargin{2};
0903                     to = varargin{3};
0904             <span class="keyword">end</span>
0905             validateattributes(from, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>,<span class="string">'scalar'</span>});
0906             validateattributes(to, {<span class="string">'numeric'</span>}, {<span class="string">'real'</span>,<span class="string">'scalar'</span>});
0907 
0908             <span class="keyword">if</span> isscalar(sp)
0909                 ii = <a href="#_sub37" class="code" title="subfunction sp = idefint(sp, varargin)">idefint</a>(sp,intvar);  <span class="comment">% indefinite integral</span>
0910                 di = <a href="#_sub48" class="code" title="subfunction sp = subs(sp, old, new)">subs</a>(ii,intvar,to) - <a href="#_sub48" class="code" title="subfunction sp = subs(sp, old, new)">subs</a>(ii,intvar,from);  <span class="comment">% substitute at the end points of the interval, then subtract</span>
0911             <span class="keyword">else</span>
0912                 di = zeros(size(sp));
0913                 <span class="keyword">for</span> k = 1 : numel(sp)
0914                     di(k) = <a href="#_sub36" class="code" title="subfunction di = defint(sp, varargin)">defint</a>(sp(k),intvar,from,to);
0915                 <span class="keyword">end</span>
0916             <span class="keyword">end</span>
0917         <span class="keyword">end</span>
0918 
0919         <a name="_sub36" href="#_subfunctions" class="code">function sp = idefint(sp, varargin)</a>
0920         <span class="comment">% Indefinite integral of symbolic polynomial.</span>
0921         <span class="comment">%</span>
0922         <span class="comment">% Input arguments:</span>
0923         <span class="comment">% intvar (optional):</span>
0924         <span class="comment">%    name of variable to integrate with respect to</span>
0925         <span class="comment">%</span>
0926         <span class="comment">% Output arguments:</span>
0927         <span class="comment">% sp:</span>
0928         <span class="comment">%    symbolic polynomial object containing the integral polynomial</span>
0929         <span class="comment">%</span>
0930         <span class="comment">% See also: sympoly.int</span>
0931 
0932             error(nargchk(1, 2, nargin, <span class="string">'struct'</span>));
0933             intvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{:});
0934 
0935             <span class="keyword">if</span> isscalar(sp)
0936                 x = <a href="sympoly.html" class="code" title="">sympoly</a>(intvar);
0937                 sp = <a href="#_sub67" class="code" title="subfunction [sp1,sp2] = unionvars(sp1, sp2)">unionvars</a>(sp,x);  <span class="comment">% ensure that intvar is a variable in this polynomial</span>
0938                 indx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp, intvar);
0939 
0940                 pow = sp.Exponents(:,indx);  <span class="comment">% which variable is it?</span>
0941                 assert(all(pow ~= -1), <span class="keyword">...</span><span class="comment">  % ln(x) is not in the sympoly space</span>
0942                     <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
0943                     <span class="string">'Cannot integrate 1/%s.'</span>, <a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(intvar));
0944 
0945                 sp.Exponents(:,indx) = sp.Exponents(:,indx) + 1;
0946                 sp.Coefficients = sp.Coefficients ./ (pow+1);
0947 
0948                 <span class="comment">% add integrand for constant term</span>
0949                 sp.Coefficients = [ sp.Coefficients ; sp.ConstantValue ];
0950                 pow = zeros(1, numel(sp.Variables));
0951                 pow(indx) = 1;
0952                 sp.Exponents = [ sp.Exponents ; pow ];
0953                 sp.ConstantValue = 0;
0954                 sp = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(sp);
0955             <span class="keyword">else</span>
0956                 <span class="keyword">for</span> k = 1 : numel(sp)
0957                     sp(k) = <a href="#_sub38" class="code" title="subfunction sp = int(sp, varargin)">int</a>(sp(k),intvar);
0958                 <span class="keyword">end</span>
0959             <span class="keyword">end</span>
0960         <span class="keyword">end</span>
0961 
0962         <a name="_sub37" href="#_subfunctions" class="code">function sp = int(sp, varargin)</a>
0963         <span class="comment">% Integrate symbolic polynomial.</span>
0964         <span class="comment">%</span>
0965         <span class="comment">% Usage:</span>
0966         <span class="comment">%    int(expr)</span>
0967         <span class="comment">%    int(expr, v)</span>
0968         <span class="comment">%    int(expr, a, b)</span>
0969         <span class="comment">%    int(expr, v, a, b)</span>
0970         <span class="comment">%</span>
0971         <span class="comment">% See also: sympoly.defint, sympoly.idefint, sym.int</span>
0972 
0973             error(nargchk(1, 4, nargin, <span class="string">'struct'</span>));
0974             <span class="keyword">switch</span> nargin
0975                 <span class="keyword">case</span> {1,2}
0976                     sp = <a href="#_sub37" class="code" title="subfunction sp = idefint(sp, varargin)">idefint</a>(sp, varargin{:});
0977                 <span class="keyword">case</span> {3,4}
0978                     sp = <a href="#_sub36" class="code" title="subfunction di = defint(sp, varargin)">defint</a>(sp, varargin{:});
0979             <span class="keyword">end</span>
0980         <span class="keyword">end</span>
0981 
0982         <a name="_sub38" href="#_subfunctions" class="code">function dpdx = diff(sp, varargin)</a>
0983         <span class="comment">% Derivative of symbolic polynomial.</span>
0984         <span class="comment">%</span>
0985         <span class="comment">% Input arguments:</span>
0986         <span class="comment">% var:</span>
0987         <span class="comment">%    variable to differentiate with respect to</span>
0988         <span class="comment">% n:</span>
0989         <span class="comment">%    order of differentiation, defaults to 1</span>
0990         <span class="comment">%</span>
0991         <span class="comment">% See also: sym.diff</span>
0992 
0993             error(nargchk(1, 3, nargin, <span class="string">'struct'</span>));
0994             <span class="keyword">switch</span> nargin
0995                 <span class="keyword">case</span> 1  <span class="comment">% diff(sp)</span>
0996                     assert(<a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(sp), <span class="keyword">...</span>
0997                         <span class="string">'math:sympoly:ArgumentCountMismatch'</span>, <span class="keyword">...</span>
0998                         <span class="string">'Variable to differentiate with respect to is unspecified.'</span>);
0999                     dvar = <a href="#_sub85" class="code" title="subfunction var = univariatesym(sp)">univariatesym</a>(sp);
1000                     n = 1;  <span class="comment">% set the order of differentiation</span>
1001                 <span class="keyword">case</span> 2
1002                     <span class="keyword">if</span> isnumeric(varargin{1})  <span class="comment">% diff(sp, 2)</span>
1003                         assert(<a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(sp), <span class="keyword">...</span>
1004                             <span class="string">'math:sympoly:ArgumentCountMismatch'</span>, <span class="keyword">...</span>
1005                             <span class="string">'Variable to differentiate with respect to is unspecified.'</span>);
1006                         dvar = <a href="#_sub85" class="code" title="subfunction var = univariatesym(sp)">univariatesym</a>(sp);  <span class="comment">% differentiate with respect to which variable?</span>
1007                         n = varargin{1};
1008                     <span class="keyword">else</span>  <span class="comment">% diff(sp, 'x')</span>
1009                         dvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{1});
1010                         n = 1;  <span class="comment">% assume n = 1 as default</span>
1011                     <span class="keyword">end</span>
1012                 <span class="keyword">case</span> 3
1013                     <span class="keyword">if</span> isnumeric(varargin{1})  <span class="comment">% diff(sp, 2, 'x')</span>
1014                         dvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{2});
1015                         n = varargin{1};
1016                     <span class="keyword">elseif</span> isnumeric(varargin{2})  <span class="comment">% diff(sp, 'x', 2)</span>
1017                         dvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{1});
1018                         n = varargin{2};
1019                     <span class="keyword">else</span>
1020                         error(<span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="string">'Arguments are of invalid type.'</span>);
1021                     <span class="keyword">end</span>
1022             <span class="keyword">end</span>
1023             validateattributes(n, {<span class="string">'numeric'</span>}, {<span class="string">'nonnegative'</span>,<span class="string">'integer'</span>,<span class="string">'scalar'</span>});
1024 
1025             <span class="keyword">if</span> isscalar(sp)
1026                 dpdx = <a href="#_sub75" class="code" title="subfunction dpdx = differentiate(sp, n, dvar)">differentiate</a>(sp, n, dvar);
1027             <span class="keyword">else</span>
1028                 dpdx = sp;
1029                 <span class="keyword">for</span> k = 1 : numel(sp)
1030                     dpdx(k) = <a href="#_sub75" class="code" title="subfunction dpdx = differentiate(sp, n, dvar)">differentiate</a>(sp(k), n, dvar);
1031                 <span class="keyword">end</span>
1032             <span class="keyword">end</span>
1033         <span class="keyword">end</span>
1034 
1035         <a name="_sub39" href="#_subfunctions" class="code">function gradp = gradient(sp)</a>
1036         <span class="comment">% Gradient vector for symbolic polynomial.</span>
1037         <span class="comment">%</span>
1038         <span class="comment">% Output arguments:</span>
1039         <span class="comment">% gradp:</span>
1040         <span class="comment">%    symbolic polynomial vector containing the gradient vector</span>
1041 
1042             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});  <span class="comment">% gradient vector supported on scalar symbolic polynomials only</span>
1043 
1044             nvar = numel(sp.Variables);
1045             <span class="keyword">if</span> nvar == 0  <span class="comment">% sympoly had no variables, i.e. it was a constant</span>
1046                 gradp = <a href="sympoly.html" class="code" title="">sympoly</a>(0);
1047             <span class="keyword">else</span>  <span class="comment">% loop over the variables</span>
1048                 gradp = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(1,nvar));
1049                 <span class="keyword">for</span> i = 1 : nvar
1050                     gradp(i) = <a href="#_sub75" class="code" title="subfunction dpdx = differentiate(sp, n, dvar)">differentiate</a>(sp, 1, sp.Variables(i));
1051                 <span class="keyword">end</span>
1052             <span class="keyword">end</span>
1053         <span class="keyword">end</span>
1054 
1055         <a name="_sub40" href="#_subfunctions" class="code">function r = roots(sp)</a>
1056         <span class="comment">% Roots of a univariate symbolic polynomial.</span>
1057         <span class="comment">%</span>
1058         <span class="comment">% See also: poly, roots, poly, polyval</span>
1059 
1060             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
1061             p = <a href="#_sub54" class="code" title="subfunction poly = sym2poly(sp)">sym2poly</a>(sp);
1062             r = <a href="#_sub41" class="code" title="subfunction r = roots(sp)">roots</a>(p);
1063         <span class="keyword">end</span>
1064 
1065         <a name="_sub41" href="#_subfunctions" class="code">function deg = degree(sp, varargin)</a>
1066         <span class="comment">% Degree of a symbolic polynomial w.r.t. a variable.</span>
1067         <span class="comment">%</span>
1068         <span class="comment">% Input arguments:</span>
1069         <span class="comment">% dvar:</span>
1070         <span class="comment">%    variable whose degree is sought, as a symvariable object or string</span>
1071 
1072             error(nargchk(1, 2, nargin, <span class="string">'struct'</span>));
1073             dvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{:});
1074 
1075             <span class="keyword">if</span> isscalar(sp)
1076                 indx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp, dvar);  <span class="comment">% find column index of variable within exponent array</span>
1077                 <span class="keyword">if</span> ~isempty(indx)
1078                     deg = max(sp.Exponents(:,indx));
1079                     assert(min(sp.Exponents(:,indx)) &gt;= 0, <span class="keyword">...</span>
1080                         <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1081                         <span class="string">'Degree is undefined for polynomial with negative exponents.'</span>)
1082                     assert(all(sp.Exponents(:,indx) == floor(sp.Exponents(:,indx))), <span class="keyword">...</span>
1083                         <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1084                         <span class="string">'Degree is undefined for fractional exponents.'</span>)
1085                 <span class="keyword">else</span>
1086                     deg = 0;
1087                 <span class="keyword">end</span>
1088             <span class="keyword">else</span>
1089                 deg = zeros(size(sp));
1090                 <span class="keyword">for</span> k = 1 : numel(sp)
1091                     deg(k) = <a href="#_sub42" class="code" title="subfunction deg = degree(sp, varargin)">degree</a>(sp(k), dvar);
1092                 <span class="keyword">end</span>
1093             <span class="keyword">end</span>
1094         <span class="keyword">end</span>
1095 
1096         <a name="_sub42" href="#_subfunctions" class="code">function deg = maxdegree(sp, varargin)</a>
1097         <span class="comment">% Greatest degree of a symbolic polynomial w.r.t. a variable.</span>
1098         <span class="comment">%</span>
1099         <span class="comment">% Input arguments:</span>
1100         <span class="comment">% dvar:</span>
1101         <span class="comment">%    variable whose degree is sought, as a symvariable object or string</span>
1102 
1103             <span class="keyword">if</span> isscalar(sp)
1104                 error(nargchk(1, 2, nargin, <span class="string">'struct'</span>));
1105             <span class="keyword">else</span>
1106                 error(nargchk(2, 2, nargin, <span class="string">'struct'</span>));
1107             <span class="keyword">end</span>
1108             dvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{:});
1109 
1110             deg = -Inf;
1111             <span class="keyword">for</span> k = 1 : numel(sp)
1112                 indx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp(k), dvar);  <span class="comment">% find column index of variable within exponent array</span>
1113                 <span class="keyword">if</span> ~isempty(indx)
1114                     d = max(sp(k).Exponents(:,indx));
1115                 <span class="keyword">else</span>
1116                     d = 0;
1117                 <span class="keyword">end</span>
1118                 <span class="keyword">if</span> d &gt; deg
1119                     deg = d;
1120                 <span class="keyword">end</span>
1121             <span class="keyword">end</span>
1122         <span class="keyword">end</span>
1123 
1124         <a name="_sub43" href="#_subfunctions" class="code">function deg = mindegree(sp, varargin)</a>
1125         <span class="comment">% Smallest degree of a symbolic polynomial w.r.t. a variable.</span>
1126         <span class="comment">%</span>
1127         <span class="comment">% Input arguments:</span>
1128         <span class="comment">% dvar:</span>
1129         <span class="comment">%    variable whose degree is sought, as a symvariable object or string</span>
1130 
1131             <span class="keyword">if</span> isscalar(sp)
1132                 error(nargchk(1, 2, nargin, <span class="string">'struct'</span>));
1133             <span class="keyword">else</span>
1134                 error(nargchk(2, 2, nargin, <span class="string">'struct'</span>));
1135             <span class="keyword">end</span>
1136             dvar = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{:});
1137 
1138             deg = Inf;
1139             <span class="keyword">for</span> k = 1 : numel(sp)
1140                 indx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp(k), dvar);  <span class="comment">% find column index of variable within exponent array</span>
1141                 <span class="keyword">if</span> ~isempty(indx)
1142                     d = min(sp(k).Exponents(:,indx));
1143                 <span class="keyword">else</span>
1144                     d = 0;
1145                 <span class="keyword">end</span>
1146                 <span class="keyword">if</span> d &lt; deg
1147                     deg = d;
1148                 <span class="keyword">end</span>
1149             <span class="keyword">end</span>
1150         <span class="keyword">end</span>
1151 
1152         <a name="_sub44" href="#_subfunctions" class="code">function [spterms,spcoeff] = terms(sp)</a>
1153         <span class="comment">% Terms of a symboic polynomial.</span>
1154 
1155             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
1156 
1157             <span class="keyword">if</span> sp.ConstantValue ~= 0
1158                 spterms = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(1, numel(sp.Coefficients) + 1));
1159             <span class="keyword">else</span>
1160                 spterms = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(1, numel(sp.Coefficients)));
1161             <span class="keyword">end</span>
1162             <span class="keyword">if</span> nargout &gt; 1
1163                 spcoeff = zeros(size(spterms));
1164             <span class="keyword">end</span>
1165 
1166             <span class="keyword">for</span> k = 1 : numel(sp.Coefficients)
1167                 <span class="keyword">if</span> nargout &gt; 1
1168                     spcoeff(k) = sp.Coefficients(k);
1169                     spterms(k).Coefficients = 1;
1170                     spterms(k).Variables = sp.Variables;
1171                     spterms(k).Exponents = sp.Exponents(k,:);
1172                     spterms(k) = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(spterms(k));
1173                 <span class="keyword">else</span>
1174                     spterms(k).Coefficients = sp.Coefficients(k);
1175                     spterms(k).Variables = sp.Variables;
1176                     spterms(k).Exponents = sp.Exponents(k,:);
1177                     spterms(k) = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(spterms(k));
1178                 <span class="keyword">end</span>
1179             <span class="keyword">end</span>
1180             <span class="keyword">if</span> sp.ConstantValue ~= 0
1181                 <span class="keyword">if</span> nargout &gt; 1
1182                     spcoeff(end) = sp.ConstantValue;
1183                     spterms(end).ConstantValue = 1;
1184                 <span class="keyword">else</span>
1185                     spterms(end).ConstantValue = sp.ConstantValue;
1186                 <span class="keyword">end</span>
1187             <span class="keyword">end</span>
1188         <span class="keyword">end</span>
1189 
1190         <a name="_sub45" href="#_subfunctions" class="code">function [coeff,terms] = coeffterms(sp, powers, varargin)</a>
1191         <span class="comment">% Coefficients of symbolic polynomial w.r.t. a variable.</span>
1192         <span class="comment">%</span>
1193         <span class="comment">% Input arguments:</span>
1194         <span class="comment">% powers:</span>
1195         <span class="comment">%    a numeric vector or a vector of univariate sympoly objects</span>
1196         <span class="comment">% var:</span>
1197         <span class="comment">%    variable a numeric power vector should be interpreter in terms of</span>
1198         <span class="comment">%</span>
1199         <span class="comment">% Output arguments:</span>
1200         <span class="comment">% coeff:</span>
1201         <span class="comment">%    coefficients of the symbolic polynomial w.r.t. the variable</span>
1202         <span class="comment">% terms:</span>
1203         <span class="comment">%    single-variable terms of the form x^p such that sp = coeff * terms</span>
1204 
1205             <span class="keyword">if</span> isnumeric(powers)
1206                 error(nargchk(2, 3, nargin, <span class="string">'struct'</span>));
1207                 pow = powers;
1208 
1209                 <span class="comment">% populate terms</span>
1210                 <a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a> = <a href="sympoly.html" class="code" title="">sympoly</a>(ones(1, numel(pow)));
1211                 var = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{:});
1212                 symvar = <a href="sympoly.html" class="code" title="">sympoly</a>(var);
1213                 <span class="keyword">for</span> i = 1 : numel(pow)
1214                     <a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(i) = symvar^pow(i);
1215                 <span class="keyword">end</span>
1216             <span class="keyword">else</span>
1217                 error(nargchk(2, 2, nargin, <span class="string">'struct'</span>));
1218                 <a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a> = powers;
1219                 validateattributes(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>, {<span class="string">'sympoly'</span>}, {<span class="string">'vector'</span>});
1220 
1221                 assert(<a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>), <span class="keyword">...</span>
1222                     <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
1223                     <span class="string">'A univariate vector of terms is expected.'</span>);
1224                 pow = zeros(size(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>));
1225                 <span class="keyword">for</span> k = 1 : numel(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>)
1226                     assert(numel(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k).Exponents) == 1 &amp;&amp; <a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k).ConstantValue == 0 &amp;&amp; <a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k).Coefficients == 1 || isempty(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k).Exponents) &amp;&amp; <a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k).ConstantValue == 1, <span class="keyword">...</span>
1227                         <span class="string">'A vector of powers of a variable is expected, e.g. [x, x^2, x^6, 1].'</span>);
1228                     <span class="keyword">if</span> ~isempty(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k).Exponents)  <span class="comment">% may be empty for constant term</span>
1229                         pow(k) = <a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k).Exponents;  <span class="comment">% a single value</span>
1230                     <span class="keyword">end</span>
1231                 <span class="keyword">end</span>
1232                 assert(numel(unique(pow)) == numel(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>), <span class="keyword">...</span>
1233                     <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
1234                     <span class="string">'A vector of different powers of a variable is expected.'</span>);
1235             <span class="keyword">end</span>
1236 
1237             <span class="comment">% find variable whose powers to extract coefficients of</span>
1238             <span class="keyword">for</span> k = 1 : numel(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>)
1239                 <span class="keyword">if</span> ~<a href="#_sub29" class="code" title="subfunction tf = isconstant(sp)">isconstant</a>(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k))
1240                     var = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>(k));
1241                     <span class="keyword">break</span>;
1242                 <span class="keyword">end</span>
1243             <span class="keyword">end</span>
1244 
1245             <span class="comment">% create coefficient array</span>
1246             <span class="keyword">if</span> isvector(sp)
1247                 coeff = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(numel(pow), numel(sp)));
1248             <span class="keyword">else</span>
1249                 coeff = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros([numel(pow), size(sp)]));
1250             <span class="keyword">end</span>
1251 
1252             <span class="comment">% populate coefficient array</span>
1253             <span class="keyword">for</span> k = 1 : numel(sp)
1254                 vindx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp(k), var);
1255                 <span class="keyword">if</span> ~isempty(vindx)  <span class="comment">% variable found in symbolic polynomial</span>
1256                     <span class="comment">% term without variable w.r.t. which coefficients are extracted</span>
1257                     baseterm = sp(k);
1258                     baseterm.Variables(:,vindx) = [];  <span class="comment">% remove variable</span>
1259                     baseterm.ConstantValue = 0;
1260                     baseterm.Exponents(:,vindx) = [];  <span class="comment">% do not garbage collect yet</span>
1261 
1262                     <span class="comment">% exponents of variable in symbolic polynomial</span>
1263                     exponents = unique(sp(k).Exponents(:,vindx));  <span class="comment">% e.g. [0 1 2 4 7]</span>
1264                     <span class="keyword">for</span> i = 1 : numel(exponents)
1265                         cindx = sp(k).Exponents(:,vindx) == exponents(i);  <span class="comment">% logical index of where given exponent is found</span>
1266                         coeffterm = baseterm;
1267                         coeffterm.Exponents = coeffterm.Exponents(cindx,:);  <span class="comment">% take only terms that belong to variable with given exponent (including zero exponent)</span>
1268                         coeffterm.Coefficients = coeffterm.Coefficients(cindx);
1269                         pindx = find(exponents(i) == pow, 1);  <span class="comment">% index of given exponent in vector of powers for entire symbolic polynomial array</span>
1270                         coeff(pindx,k) = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(coeffterm);  <span class="comment">% k is a pseudo-linear index for dimensions higher than 1</span>
1271                     <span class="keyword">end</span>
1272                 <span class="keyword">end</span>
1273                 pindx = find(0 == pow, 1);
1274                 <span class="keyword">if</span> ~isempty(pindx)
1275                     coeff(pindx,k) = coeff(pindx,k) + sp(k).ConstantValue;
1276                 <span class="keyword">end</span>
1277             <span class="keyword">end</span>
1278             coeff = shiftdim(coeff, 1);
1279         <span class="keyword">end</span>
1280 
1281         <a name="_sub46" href="#_subfunctions" class="code">function [coeff,terms] = coeffs(sp, varargin)</a>
1282         <span class="comment">% Coefficients of symbolic polynomial w.r.t. a variable.</span>
1283         <span class="comment">%</span>
1284         <span class="comment">% Output arguments:</span>
1285         <span class="comment">% coeff:</span>
1286         <span class="comment">%    coefficients of the symbolic polynomial w.r.t. the variable</span>
1287         <span class="comment">% terms:</span>
1288         <span class="comment">%    single-variable terms of the form x^p such that sp = coeff * terms</span>
1289         <span class="comment">%</span>
1290         <span class="comment">% Examples:</span>
1291         <span class="comment">% &gt;&gt; sympolys x y z;</span>
1292         <span class="comment">% &gt;&gt; [c,t] = coeffs(x^3+y^2+z+1, x)</span>
1293         <span class="comment">% c =</span>
1294         <span class="comment">%    [ y^2 + z + 1  1 ]</span>
1295         <span class="comment">% t =</span>
1296         <span class="comment">%    [ 1  x^3 ]</span>
1297         <span class="comment">% &gt;&gt; [c,t] = coeffs([x^3+y^2+z+1 x^2+x*z ; x+y 1], x);</span>
1298         <span class="comment">% &gt;&gt; t</span>
1299         <span class="comment">% t =</span>
1300         <span class="comment">%    sympoly array of size = [1  4]</span>
1301         <span class="comment">%    [ 1  x  x^2  x^3 ]</span>
1302         <span class="comment">% &gt;&gt; c(:,:,1)</span>
1303         <span class="comment">% ans =</span>
1304         <span class="comment">%    [ y^2 + z + 1  0 ]</span>
1305         <span class="comment">%    [           y  1 ]</span>
1306         <span class="comment">% &gt;&gt; c(:,:,2)</span>
1307         <span class="comment">% ans =</span>
1308         <span class="comment">%    [ 0  z ]</span>
1309         <span class="comment">%    [ 1  0 ]</span>
1310         <span class="comment">%</span>
1311         <span class="comment">% See also: sym.coeffs, coeffterms</span>
1312 
1313             error(nargchk(1, 2, nargin, <span class="string">'struct'</span>));
1314             var = <a href="#_sub83" class="code" title="subfunction sv = variablename(sp, var)">variablename</a>(sp, varargin{:});
1315 
1316             <span class="comment">% determine the number of different terms</span>
1317             pow = 0;  <span class="comment">% powers of variable in symbolic polynomial array</span>
1318             <span class="keyword">for</span> k = 1 : numel(sp)
1319                 vindx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp(k), var);
1320                 <span class="keyword">if</span> ~isempty(vindx)  <span class="comment">% variable found in symbolic polynomial</span>
1321                     pow = union(pow, sp(k).Exponents(:,vindx));  <span class="comment">% add powers of variable</span>
1322                 <span class="keyword">end</span>
1323             <span class="keyword">end</span>
1324 
1325             [coeff,<a href="#_sub45" class="code" title="subfunction [spterms,spcoeff] = terms(sp)">terms</a>] = <a href="#_sub46" class="code" title="subfunction [coeff,terms] = coeffterms(sp, powers, varargin)">coeffterms</a>(sp, pow, var);
1326         <span class="keyword">end</span>
1327 
1328         <a name="_sub47" href="#_subfunctions" class="code">function sp = subs(sp, old, new)</a>
1329         <span class="comment">% Substitution into symbolic polynomial.</span>
1330         <span class="comment">%</span>
1331         <span class="comment">% Input arguments:</span>
1332         <span class="comment">% old (optional):</span>
1333         <span class="comment">%    symbolic variable or variable name to substitute for</span>
1334         <span class="comment">% new:</span>
1335         <span class="comment">%    symbolic polynomial or numeric value to substitute</span>
1336         <span class="comment">%</span>
1337         <span class="comment">% Examples:</span>
1338         <span class="comment">% &gt;&gt; sympoly x y;           % defines sympolys &quot;x&quot; and &quot;y&quot;</span>
1339         <span class="comment">% &gt;&gt; r = subs(x+1,'x',2*x); % adds 1, substitutes 2*x for x</span>
1340         <span class="comment">% r =</span>
1341         <span class="comment">%    2*x + 1</span>
1342         <span class="comment">% &gt;&gt; r = subs(x^2+1,x^2,y);</span>
1343         <span class="comment">% r =</span>
1344         <span class="comment">%    y + 1</span>
1345 
1346             error(nargchk(2,3,nargin,<span class="string">'struct'</span>));
1347 
1348             <span class="keyword">if</span> nargin &lt; 3  <span class="comment">% only one extra argument, can we do the substitution?</span>
1349                 assert(<a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(sp), <span class="keyword">...</span>
1350                     <span class="string">'math:sympoly:ArgumentCountMismatch'</span>, <span class="keyword">...</span>
1351                         <span class="string">'Supply a variable to substitute for.'</span>);
1352                 new = old;
1353                 old = <a href="#_sub85" class="code" title="subfunction var = univariatesym(sp)">univariatesym</a>(sp);
1354             <span class="keyword">end</span>
1355 
1356             <span class="keyword">if</span> ischar(old)
1357                 validateattributes(old, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'vector'</span>});
1358                 oldsym = <a href="sympoly.html" class="code" title="">sympoly</a>(old);
1359             <span class="keyword">elseif</span> isa(old, <span class="string">'symvariable'</span>)
1360                 validateattributes(old, {<span class="string">'symvariable'</span>}, {<span class="string">'scalar'</span>});
1361                 oldsym = <a href="sympoly.html" class="code" title="">sympoly</a>(old);
1362             <span class="keyword">elseif</span> isa(old, <span class="string">'sympoly'</span>)
1363                 validateattributes(old, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
1364                 assert(<a href="#_sub34" class="code" title="subfunction tf = issingleterm(sp)">issingleterm</a>(old), <span class="keyword">...</span>
1365                     <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
1366                     <span class="string">'A single term like c * x^p * y^q * z^r is expected.'</span>);
1367                 oldsym = old;
1368             <span class="keyword">elseif</span> iscell(old) &amp;&amp; iscell(new)
1369                 validateattributes(old, {<span class="string">'cell'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'vector'</span>}, 2);
1370                 validateattributes(new, {<span class="string">'cell'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'vector'</span>}, 3);
1371                 assert(numel(old) == numel(new), <span class="keyword">...</span><span class="comment">  % verify if they have the same number of elements</span>
1372                     <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
1373                     <span class="string">'Substitution requires the same number of elements for old and new.'</span>);
1374 
1375                 <span class="keyword">for</span> k = 1 : numel(old)
1376                     sp = <a href="#_sub48" class="code" title="subfunction sp = subs(sp, old, new)">subs</a>(sp, <a href="sympoly.html" class="code" title="">sympoly</a>(old{k}), <a href="sympoly.html" class="code" title="">sympoly</a>(new{k}));
1377                 <span class="keyword">end</span>
1378                 <span class="keyword">return</span>;
1379             <span class="keyword">else</span>
1380                 error(<span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
1381                     <span class="string">'Unrecognized type &quot;%s&quot; to substitute for.'</span>, class(old));
1382             <span class="keyword">end</span>
1383             <span class="keyword">if</span> ischar(new)
1384                 validateattributes(new, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'vector'</span>});
1385                 newsym = <a href="sympoly.html" class="code" title="">sympoly</a>(new);
1386             <span class="keyword">elseif</span> isa(new, <span class="string">'symvariable'</span>)
1387                 validateattributes(new, {<span class="string">'symvariable'</span>}, {<span class="string">'scalar'</span>});
1388                 newsym = <a href="sympoly.html" class="code" title="">sympoly</a>(new);
1389             <span class="keyword">else</span>
1390                 validateattributes(new, {<span class="string">'numeric'</span>,<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
1391                 newsym = new;
1392             <span class="keyword">end</span>
1393 
1394             <span class="keyword">if</span> isscalar(sp)
1395                 sp = <a href="#_sub76" class="code" title="subfunction sp = substitute(sp, old, new)">substitute</a>(sp, oldsym, newsym);
1396             <span class="keyword">else</span>  <span class="comment">% perform substitution for all entries</span>
1397                 <span class="keyword">for</span> k = 1 : numel(sp)
1398                     sp(k) = <a href="#_sub76" class="code" title="subfunction sp = substitute(sp, old, new)">substitute</a>(sp(k), oldsym, newsym);
1399                 <span class="keyword">end</span>
1400             <span class="keyword">end</span>
1401         <span class="keyword">end</span>
1402 
1403         <a name="_sub48" href="#_subfunctions" class="code">function sp = subspower(sp, old, new)</a>
1404         <span class="comment">% Substitution of exact power into symbolic polynomial.</span>
1405         <span class="comment">%</span>
1406         <span class="comment">% Examples:</span>
1407         <span class="comment">% &gt;&gt; sympolys x y;</span>
1408         <span class="comment">% &gt;&gt; r = subspower(x^2+1,x^2,y)</span>
1409         <span class="comment">% r =</span>
1410         <span class="comment">%    y + 2</span>
1411         <span class="comment">% &gt;&gt; r = subspower(x^2+1,x,y)</span>
1412         <span class="comment">% r =</span>
1413         <span class="comment">%    x^2 + 1</span>
1414 
1415             <span class="keyword">if</span> nargin &lt; 3  <span class="comment">% only one extra argument, can we do the substitution?</span>
1416                 assert(<a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(sp), <span class="keyword">...</span>
1417                     <span class="string">'math:sympoly:ArgumentCountMismatch'</span>, <span class="keyword">...</span>
1418                         <span class="string">'Supply a variable to substitute for.'</span>);
1419                 new = old;
1420                 old = <a href="#_sub85" class="code" title="subfunction var = univariatesym(sp)">univariatesym</a>(sp);
1421             <span class="keyword">end</span>
1422 
1423             <span class="keyword">if</span> ischar(old)
1424                 validateattributes(old, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'vector'</span>});
1425                 oldsym = <a href="sympoly.html" class="code" title="">sympoly</a>(name);
1426             <span class="keyword">elseif</span> isa(old, <span class="string">'sympoly'</span>)
1427                 validateattributes(old, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
1428                 assert(<a href="#_sub34" class="code" title="subfunction tf = issingleterm(sp)">issingleterm</a>(old) &amp;&amp; old.Coefficients == 1, <span class="keyword">...</span>
1429                     <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1430                     <span class="string">'A monomial with unit coefficient (a term like x^p * y^q * z^r) is expected.'</span>);
1431                 oldsym = old;
1432             <span class="keyword">end</span>
1433 
1434             <span class="keyword">if</span> isscalar(sp)
1435                 sp = <a href="#_sub77" class="code" title="subfunction sp = substitutepower(sp, old, new)">substitutepower</a>(sp, oldsym, new);
1436             <span class="keyword">else</span>  <span class="comment">% perform substitution for all entries</span>
1437                 <span class="keyword">for</span> k = 1 : numel(sp)
1438                     sp(k) = <a href="#_sub77" class="code" title="subfunction sp = substitutepower(sp, old, new)">substitutepower</a>(sp(k), oldsym, new);
1439                 <span class="keyword">end</span>
1440             <span class="keyword">end</span>
1441         <span class="keyword">end</span>
1442 
1443         <a name="_sub49" href="#_subfunctions" class="code">function [polymean,polyvar] = errorprop(sp, vars, means, stds)</a>
1444         <span class="comment">% Symbolic mean and variance given normal components.</span>
1445         <span class="comment">%</span>
1446         <span class="comment">% Input arguments:</span>
1447         <span class="comment">% vars:</span>
1448         <span class="comment">%    the (string) name of a variable in the symbolic polynomial or a</span>
1449         <span class="comment">%    symbolic polynomial of a single variable, or a cell array of these, or</span>
1450         <span class="comment">%    a vector of symbolic polynomials if multiple variables are to be</span>
1451         <span class="comment">%    considered</span>
1452         <span class="comment">% means:</span>
1453         <span class="comment">%    a numeric vector or a vector of symbolic polynomials, representing</span>
1454         <span class="comment">%    variable means, one for each element in vars</span>
1455         <span class="comment">% stds:</span>
1456         <span class="comment">%    a numeric vector or a vector of symbolic polynomials, representing</span>
1457         <span class="comment">%    variable standard deviations, one for element in vars</span>
1458         <span class="comment">%</span>
1459         <span class="comment">% Output arguments:</span>
1460         <span class="comment">% polymean:</span>
1461         <span class="comment">%    the expected value of the symbolic polynomial as a symbolic</span>
1462         <span class="comment">%    polynomial, given independent normally distributed variables as given</span>
1463         <span class="comment">%    by the input arguments</span>
1464         <span class="comment">% polyvar:</span>
1465         <span class="comment">%    the variance of the symbolic polynomial as symbolic polynomial</span>
1466         <span class="comment">%</span>
1467         <span class="comment">% Example:</span>
1468         <span class="comment">% 1. Given a unit normal N(0,1) random variable, compute the mean and variance</span>
1469         <span class="comment">% of p(x) = 3*x + 2*x^2 - x^3.</span>
1470         <span class="comment">%</span>
1471         <span class="comment">% &gt;&gt; sympoly x</span>
1472         <span class="comment">% &gt;&gt; errorprop(3*x + 2*x^2 - x^3, x, 0, 1);</span>
1473         <span class="comment">% polymean =</span>
1474         <span class="comment">%    2</span>
1475         <span class="comment">% polyvar =</span>
1476         <span class="comment">%    14</span>
1477         <span class="comment">%</span>
1478         <span class="comment">% 2. Given normal random variables x and y, where x is N(mux,sx^2) and y has</span>
1479         <span class="comment">% parameters N(muy,sy^2), compute the mean and variance of x*y.</span>
1480         <span class="comment">%</span>
1481         <span class="comment">% &gt;&gt; sympoly x y mux muy sx sy</span>
1482         <span class="comment">% &gt;&gt; [polymean,polyvar] = errorprop(x*y, {'x','y'}, [mux,muy], [sx,sy])</span>
1483         <span class="comment">% polymean =</span>
1484         <span class="comment">%    mux*muy</span>
1485         <span class="comment">% polyvar =</span>
1486         <span class="comment">%    mux^2*sy^2 + muy^2*sx^2 + sx^2*sy^2</span>
1487 
1488             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
1489 
1490             <span class="keyword">if</span> ~iscell(vars)  <span class="comment">% was there only one variable provided?</span>
1491                 <span class="keyword">if</span> isa(vars, <span class="string">'sympoly'</span>)
1492                     vars = num2cell(vars);
1493                 <span class="keyword">else</span>  <span class="comment">% variable name as string or symvariable object</span>
1494                     vars = { vars };
1495                 <span class="keyword">end</span>
1496             <span class="keyword">end</span>
1497             nvars = numel(vars);
1498 
1499             <span class="keyword">for</span> k = 1 : nvars
1500                 <span class="keyword">if</span> isa(vars{k}, <span class="string">'sympoly'</span>)
1501                     validateattributes(vars{k}, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
1502                     assert(<a href="#_sub33" class="code" title="subfunction tf = issinglevariable(sp)">issinglevariable</a>(vars{k}), <span class="keyword">...</span>
1503                         <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1504                         <span class="string">'A single-term degree-one variable with unit coefficient is expected.'</span>);
1505                     vars{k} = <a href="#_sub85" class="code" title="subfunction var = univariatesym(sp)">univariatesym</a>(vars{k});
1506                 <span class="keyword">elseif</span> isa(vars{k}, <span class="string">'symvariable'</span>)
1507                     validateattributes(vars{k}, {<span class="string">'symvariable'</span>}, {<span class="string">'scalar'</span>});
1508                 <span class="keyword">else</span>
1509                     validateattributes(vars{k}, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});
1510                 <span class="keyword">end</span>
1511             <span class="keyword">end</span>
1512 
1513             <span class="keyword">if</span> isnumeric(means)
1514                 validateattributes(means, {<span class="string">'numeric'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'real'</span>,<span class="string">'vector'</span>});
1515             <span class="keyword">else</span>
1516                 validateattributes(means, {<span class="string">'sympoly'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'vector'</span>});
1517             <span class="keyword">end</span>
1518             means = means(:);
1519 
1520             <span class="keyword">if</span> isnumeric(stds)
1521                 validateattributes(stds, {<span class="string">'numeric'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'real'</span>,<span class="string">'nonnegative'</span>,<span class="string">'vector'</span>});
1522             <span class="keyword">else</span>
1523                 validateattributes(stds, {<span class="string">'sympoly'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'vector'</span>});
1524             <span class="keyword">end</span>
1525             stds = stds(:);
1526 
1527             validateattributes(means, {<span class="string">'numeric'</span>,<span class="string">'sympoly'</span>}, {<span class="string">'size'</span>,[nvars,1]});
1528             validateattributes(stds, {<span class="string">'numeric'</span>,<span class="string">'sympoly'</span>}, {<span class="string">'size'</span>,[nvars,1]});
1529 
1530             <span class="comment">% compute the expected value polynomial E(x)</span>
1531             polymean = <a href="#_sub78" class="code" title="subfunction polymean = errormean(sp, vars, means, stds)">errormean</a>(sp, vars, means, stds);
1532             <span class="keyword">if</span> nargout &gt; 1
1533                 <span class="comment">% compute the variance polynomial V(x) = E( (x - E(x))^2 )</span>
1534                 polystd = sp - polymean;
1535                 polyvar = <a href="#_sub78" class="code" title="subfunction polymean = errormean(sp, vars, means, stds)">errormean</a>(polystd.*polystd, vars, means, stds);
1536             <span class="keyword">end</span>
1537         <span class="keyword">end</span>
1538 
1539         <a name="_sub50" href="#_subfunctions" class="code">function [polymean,polyvar] = polyerrorprop(sp, vars, means, stds)</a>
1540         <span class="comment">% Compatibility method.</span>
1541         <span class="comment">%</span>
1542         <span class="comment">% See also: sympoly.errorprop</span>
1543 
1544             [polymean,polyvar] = <a href="#_sub50" class="code" title="subfunction [polymean,polyvar] = errorprop(sp, vars, means, stds)">errorprop</a>(sp, vars, means, stds);
1545         <span class="keyword">end</span>
1546 
1547         <a name="_sub51" href="#_subfunctions" class="code">function cp = poly(sp, var)</a>
1548         <span class="comment">% Compute characteristic polynomial of symbolic polynomial matrix.</span>
1549 
1550             cp = <a href="#_sub35" class="code" title="subfunction spd = det(sp)">det</a>(sp - <a href="sympoly.html" class="code" title="">sympoly</a>(var).*eye(size(sp)));
1551         <span class="keyword">end</span>
1552 
1553         <a name="_sub52" href="#_subfunctions" class="code">function sp = renamevars(sp, from, to)</a>
1554         <span class="comment">% Map each variable of a symbolic polynomial to another.</span>
1555         <span class="comment">%</span>
1556         <span class="comment">% Examples:</span>
1557         <span class="comment">% &gt;&gt; x = sympoly('x')</span>
1558         <span class="comment">% &gt;&gt; y = sympoly('y')</span>
1559         <span class="comment">% &gt;&gt; renamevars(x+2*y, {'x'}, {'z'})         % returns 2*y+z</span>
1560         <span class="comment">% &gt;&gt; renamevars(y*x^2, {'x','y'}, {'a','b'}) % returns a^2*b</span>
1561 
1562             <span class="keyword">if</span> isscalar(sp)
1563                 <span class="keyword">if</span> ~isempty(sp.Variables)
1564                     [from,ix] = sort(from);
1565                     to = to(ix);
1566 
1567                     <span class="comment">% test if &quot;from&quot; is a superset of variables in polynomial</span>
1568                     <span class="keyword">if</span> iscellstr(sp.Variables)
1569                         assert(iscellstr(from), <span class="keyword">...</span>
1570                             <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
1571                             <span class="string">'The set of variables to rename from must the of the same type as those in polynomial.'</span>);
1572                         allvars = union(sp.Variables, from);
1573                         assert(iscellstr(to) || numel(from) == numel(allvars) &amp;&amp; all(strcmp(from, allvars)), <span class="keyword">...</span>
1574                             <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1575                             <span class="string">'Either list all variables or use compatible types for source and target variable sets.'</span>);
1576                     <span class="keyword">else</span>
1577                         assert(strcmp(class(from), class(sp.Variables)), <span class="keyword">...</span>
1578                             <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
1579                             <span class="string">'The set of variables to rename from must the of the same type as those in polynomial.'</span>);
1580                         allvars = union(sp.Variables, from);
1581                         assert(strcmp(class(from), class(to)) || numel(from) == numel(allvars) &amp;&amp; all(from == allvars), <span class="keyword">...</span>
1582                             <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1583                             <span class="string">'Either list all variables or use compatible types for source and target variable sets.'</span>);
1584                     <span class="keyword">end</span>
1585 
1586                     assert(numel(to) == numel(unique(to)), <span class="keyword">...</span>
1587                         <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1588                         <span class="string">'Variables in new polynomial must be unique.'</span>);
1589 
1590                     ix = zeros(size(sp.Variables));  <span class="comment">% index of variables in symbolic polynomial within the set &quot;from&quot;</span>
1591                     <span class="keyword">for</span> k = 1 : numel(sp.Variables)
1592                         ixfrom = sympoly.findvarinset(sp.Variables(k), from);
1593                         <span class="keyword">if</span> ~isempty(ixfrom)
1594                             ix(k) = ixfrom;
1595                         <span class="keyword">end</span>
1596                     <span class="keyword">end</span>
1597                     <span class="keyword">if</span> nnz(ix) &lt; numel(ix)  <span class="comment">% some variables are missing from &quot;from&quot;</span>
1598                         sp.Variables(ix &gt; 0) = to(ix(ix &gt; 0));
1599                     <span class="keyword">else</span>  <span class="comment">% all variables appear in &quot;from&quot;</span>
1600                         sp.Variables = to(ix);
1601                     <span class="keyword">end</span>
1602 
1603                     <span class="comment">% restore alphabetic order of variables</span>
1604                     sp = <a href="#_sub66" class="code" title="subfunction sp = sortvars(sp)">sortvars</a>(sp);
1605 
1606                     <span class="comment">% ensure that all variables are unique</span>
1607                     uniqueselector = [ true , sp.Variables(2:end) ~= sp.Variables(1:end-1) ].';
1608 
1609                     <span class="keyword">if</span> ~all(uniqueselector)  <span class="comment">% some variables are not unique</span>
1610                         <span class="comment">% form groups of elements, each vector element is a group index</span>
1611                         grp = cumsum(uniqueselector);
1612 
1613                         <span class="comment">% calculate run length for the groups</span>
1614                         runs = accumarray(grp,1);
1615 
1616                         <span class="comment">% add coefficients that have the same set of exponents</span>
1617                         exponents = zeros(numel(sp.Coefficients),numel(runs));
1618                         rs = 1;  <span class="comment">% range start index</span>
1619                         <span class="keyword">for</span> k = 1 : numel(runs)
1620                             re = rs + runs(k) - 1;  <span class="comment">% range end index</span>
1621                             exponents(:,k) = <a href="#_sub25" class="code" title="subfunction sump = sum(sp, varargin)">sum</a>(sp.Exponents(:,rs:re), 2);
1622                             rs = re + 1;
1623                         <span class="keyword">end</span>
1624 
1625                         <span class="comment">% normalize variables and set exponent matrix</span>
1626                         sp.Variables = sp.Variables(uniqueselector);
1627                         sp.Exponents = exponents;
1628 
1629                         sp = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(sp);
1630                     <span class="keyword">end</span>
1631                 <span class="keyword">end</span>
1632             <span class="keyword">else</span>
1633                 <span class="keyword">for</span> k = 1 : numel(sp)
1634                     sp(k) = <a href="#_sub53" class="code" title="subfunction sp = renamevars(sp, from, to)">renamevars</a>(sp(k), from, to);
1635                 <span class="keyword">end</span>
1636             <span class="keyword">end</span>
1637         <span class="keyword">end</span>
1638 
1639         <a name="_sub53" href="#_subfunctions" class="code">function poly = sym2poly(sp)</a>
1640         <span class="comment">% Convert univariate symbolic polynomial to numeric polynomial.</span>
1641         <span class="comment">%</span>
1642         <span class="comment">% Example:</span>
1643         <span class="comment">% &gt;&gt; sym2poly(3*x^4 + x^2 + 6*x + 5)   returns [3 0 1 6 5]</span>
1644         <span class="comment">%</span>
1645         <span class="comment">% See also: sym.sym2poly, polyval, poly, roots</span>
1646 
1647             assert(<a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(sp), <span class="keyword">...</span>
1648                 <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1649                 <span class="string">'Operation supported on univariate polynomials only.'</span>);
1650             assert(all(sp.Exponents == floor(sp.Exponents) &amp; sp.Exponents &gt; 0), <span class="keyword">...</span>
1651                 <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
1652                 <span class="string">'Negative and fractional exponents are not supported.'</span>);
1653 
1654             <a href="#_sub52" class="code" title="subfunction cp = poly(sp, var)">poly</a> = zeros(1, max(sp.Exponents)+1);
1655             <a href="#_sub52" class="code" title="subfunction cp = poly(sp, var)">poly</a>(end) = sp.ConstantValue;
1656             <a href="#_sub52" class="code" title="subfunction cp = poly(sp, var)">poly</a>(end-sp.Exponents) = sp.Coefficients;
1657         <span class="keyword">end</span>
1658 
1659         <a name="_sub54" href="#_subfunctions" class="code">function [expr,vars] = sym(sp)</a>
1660         <span class="comment">% Convert symbolic polynomial to Symbolic Toolbox sym class.</span>
1661         <span class="comment">%</span>
1662         <span class="comment">% See also: sym</span>
1663 
1664             <span class="keyword">if</span> isscalar(sp)
1665                 [expr,vars] = <a href="#_sub79" class="code" title="subfunction [expr,vars] = symobject(sp)">symobject</a>(sp);
1666             <span class="keyword">else</span>
1667                 assert(nargout &lt; 2, <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="string">'Two-argument mode supported with scalar symbolic polynomials only.'</span>);
1668 
1669                 expr = <a href="#_sub55" class="code" title="subfunction [expr,vars] = sym(sp)">sym</a>(zeros(size(sp)));
1670                 <span class="keyword">for</span> k = 1 : numel(sp)
1671                     expr(k) = <a href="#_sub79" class="code" title="subfunction [expr,vars] = symobject(sp)">symobject</a>(sp(k));
1672                 <span class="keyword">end</span>
1673             <span class="keyword">end</span>
1674         <span class="keyword">end</span>
1675 
1676         <a name="_sub55" href="#_subfunctions" class="code">function str = code(sp, varargin)</a>
1677         <span class="comment">% Emit MatLab code that reproduces symbolic polynomial array.</span>
1678         <span class="comment">% The generated code can be passed to the built-in eval function.</span>
1679         <span class="comment">%</span>
1680         <span class="comment">% Input arguments:</span>
1681         <span class="comment">% name (optional):</span>
1682         <span class="comment">%    the name of the variable to assign to</span>
1683         <span class="comment">% aggfun (optional):</span>
1684         <span class="comment">%    the name of an aggregator function to apply to all elements of the</span>
1685         <span class="comment">%    resulting array, e.g. 'sum' or 'mean'</span>
1686         <span class="comment">%</span>
1687         <span class="comment">% See also: eval</span>
1688 
1689             error(nargchk(1, 3, nargin, <span class="string">'struct'</span>));
1690             <span class="keyword">if</span> nargin &gt; 1 &amp;&amp; ~isempty(varargin{1})
1691                 name = varargin{1};
1692                 validateattributes(name, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>}, 1);
1693             <span class="keyword">else</span>
1694                 name = <span class="string">''</span>;
1695             <span class="keyword">end</span>
1696             <span class="keyword">if</span> nargin &gt; 2 &amp;&amp; ~isempty(varargin{2})
1697                 <span class="keyword">if</span> isa(varargin{2}, <span class="string">'function_handle'</span>)
1698                     aggfun = func2str(varargin{2});
1699                     assert(~isempty(regexp(aggfun, <span class="string">'^[a-zA-Z][a-zA-Z0-9_]*$'</span>,<span class="string">'once'</span>)), <span class="keyword">...</span>
1700                         <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
1701                         <span class="string">'Code generation with aggregation expects the name of a function or the handle of a non-inline function.'</span>)
1702                 <span class="keyword">else</span>
1703                     aggfun = varargin{2};
1704                     validateattributes(aggfun, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>}, 2);
1705                 <span class="keyword">end</span>
1706             <span class="keyword">else</span>
1707                 aggfun = <span class="string">''</span>;
1708             <span class="keyword">end</span>
1709 
1710             <span class="keyword">if</span> isempty(sp)
1711                 str = sprintf(<span class="string">'%s.empty([%s])'</span>, class(sp), int2str(size(sp)));
1712             <span class="keyword">elseif</span> ndims(sp) &gt; 2
1713                 assert(~isempty(name), <span class="keyword">...</span>
1714                     <span class="string">'math:sympoly:ArgumentCountMismatch'</span>, <span class="keyword">...</span>
1715                     <span class="string">'Code generation for n-d arrays expects a variable name to assign to.'</span>);
1716 
1717                 s = size(sp);
1718                 s = s(3:end);  <span class="comment">% skip first two dimensions</span>
1719                 sk = [0,ones(1,numel(s)-1)];
1720                 strs = cell(1, <a href="#_sub24" class="code" title="subfunction prodp = prod(sp, varargin)">prod</a>(s));
1721                 <span class="keyword">for</span> k = 1 : <a href="#_sub24" class="code" title="subfunction prodp = prod(sp, varargin)">prod</a>(s)
1722                     <span class="comment">% convert linear index to subscript index</span>
1723                     sk(1) = sk(1)+1;
1724                     <span class="keyword">while</span> any(sk &gt; s)
1725                         i = find(sk &gt; s, 1);  <span class="comment">% overflow in a dimension</span>
1726                         sk(i) = 1;
1727                         sk(i+1) = sk(i+1)+1;
1728                     <span class="keyword">end</span>
1729                     strs{k} = sprintf(<span class="string">'\n%s(:,:,%s) = ...\n%s;'</span>, name, <a href="strjoin.html" class="code" title="function string = strjoin(items, adjoiner)">strjoin</a>(sk, <span class="string">','</span>), <a href="#_sub56" class="code" title="subfunction str = code(sp, varargin)">code</a>(sp(:,:,k), varargin{:}));  <span class="comment">% generate code for two-dimensional array</span>
1730                 <span class="keyword">end</span>
1731                 str = sprintf(<span class="string">'%s = %s(zeros(%s));%s'</span>, name, class(sp), <a href="strjoin.html" class="code" title="function string = strjoin(items, adjoiner)">strjoin</a>(size(sp), <span class="string">','</span>), cell2mat(strs));
1732             <span class="keyword">else</span>
1733                 <span class="keyword">if</span> ~isempty(aggfun)
1734                     fun = @(elem) [ aggfun <span class="string">'('</span> <a href="#_sub58" class="code" title="subfunction str = string(sp, cformat)">string</a>(elem, <span class="string">'code'</span>) <span class="string">')'</span> ];  <span class="comment">% generate code for a scalar symbolic polynomial using an aggregator function</span>
1735                 <span class="keyword">else</span>
1736                     fun = @(elem) <a href="#_sub58" class="code" title="subfunction str = string(sp, cformat)">string</a>(elem, <span class="string">'code'</span>);
1737                 <span class="keyword">end</span>
1738                 str = <a href="#_sub80" class="code" title="subfunction str = formatmatrix(sp, fun, colsep, rowsep, linesep, open, close)">formatmatrix</a>(sp, fun, <span class="string">','</span>, <span class="string">';'</span>, sprintf(<span class="string">' ...\n'</span>), <span class="string">'['</span>, <span class="string">']'</span>);
1739             <span class="keyword">end</span>
1740         <span class="keyword">end</span>
1741 
1742         <a name="_sub56" href="#_subfunctions" class="code">function str = latex(sp)</a>
1743         <span class="comment">% LaTeX representation of a symbolic polynomial array.</span>
1744         <span class="comment">%</span>
1745         <span class="comment">% Examples:</span>
1746         <span class="comment">% &gt;&gt; sympolys x y lambda;</span>
1747         <span class="comment">% &gt;&gt; e = x^-1 - 2*lambda^48;</span>
1748         <span class="comment">% &gt;&gt; latex(e)     % returns '-2 \lambda^{48} + x^{-1}'</span>
1749         <span class="comment">% &gt;&gt; latex([x;y]) % returns '\left[\begin{array}{r} x \\ y \end{array}\right]'</span>
1750 
1751             <span class="keyword">if</span> isempty(sp)
1752                 str = <span class="string">''</span>;
1753             <span class="keyword">elseif</span> ndims(sp) &gt; 2
1754                 error(<span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
1755                     <span class="string">'Only vectors or matrices may be converted to LaTeX, n-dimensional arrays are not supported.'</span>);
1756             <span class="keyword">else</span>
1757                 alignment = <span class="string">'r'</span>;
1758                 <a href="../../../src/@RemoteControlBoardRemapper/open.html" class="code" title="function open(obj,partList,jointsList)">open</a> = sprintf(<span class="string">'\\left[\\begin{array}{%s}\n   '</span>, alignment(ones(1,size(sp,2))));  <span class="comment">% e.g. \begin{array}{rrrr}</span>
1759                 close = sprintf(<span class="string">'\\end{array}\\right]'</span>);
1760                 str = <a href="#_sub80" class="code" title="subfunction str = formatmatrix(sp, fun, colsep, rowsep, linesep, open, close)">formatmatrix</a>(sp, @(elem) <a href="#_sub58" class="code" title="subfunction str = string(sp, cformat)">string</a>(elem, <span class="string">'latex'</span>), <span class="string">' &amp;'</span>, <span class="string">' \\'</span>, sprintf(<span class="string">'\n'</span>), <a href="../../../src/@RemoteControlBoardRemapper/open.html" class="code" title="function open(obj,partList,jointsList)">open</a>, close);
1761             <span class="keyword">end</span>
1762         <span class="keyword">end</span>
1763 
1764         <a name="_sub57" href="#_subfunctions" class="code">function str = string(sp, cformat)</a>
1765         <span class="comment">% Convert symbolic polynomial expression to a string.</span>
1766         <span class="comment">%</span>
1767         <span class="comment">% Input arguments:</span>
1768         <span class="comment">% cformat:</span>
1769         <span class="comment">%    number formatting for coefficients</span>
1770 
1771             <span class="keyword">if</span> isempty(sp)
1772                 str = <span class="string">''</span>;
1773                 <span class="keyword">return</span>
1774             <span class="keyword">end</span>
1775 
1776             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
1777 
1778             constant = sp.ConstantValue;
1779             coefficients = sp.Coefficients;
1780             exponents = sp.Exponents;
1781             <a href="#_sub28" class="code" title="subfunction vars = variables(sp)">variables</a> = sp.Variables;
1782 
1783             <span class="comment">% sort coefficients in human-readable order</span>
1784             [exponents,ix] = sortrows(exponents, -(1:numel(<a href="#_sub28" class="code" title="subfunction vars = variables(sp)">variables</a>)));
1785             coefficients = coefficients(ix);
1786 
1787             mapvarname = @(name) name;
1788             mappower = @num2str;
1789             cformat = lower(cformat);
1790             <span class="keyword">switch</span> cformat
1791                 <span class="keyword">case</span> <span class="string">'code'</span>
1792                     cformat = <span class="string">'longg'</span>;
1793                     signmul = <span class="string">'.*'</span>;
1794                     signpow = <span class="string">'.^'</span>;
1795                 <span class="keyword">case</span> <span class="string">'latex'</span>
1796                     mapvarname = @(name) <a href="latexgreek.html" class="code" title="function s = latexgreek(s)">latexgreek</a>(name);
1797                     mappower = @(<a href="#_sub21" class="code" title="subfunction sp = power(sp,n)">power</a>) [<span class="string">'{'</span> num2str(<a href="#_sub21" class="code" title="subfunction sp = power(sp,n)">power</a>) <span class="string">'}'</span>];
1798                     cformat = <span class="string">'longg'</span>;
1799                     signmul = <span class="string">' '</span>;
1800                     signpow = <span class="string">'^'</span>;
1801                 <span class="keyword">case</span> {<span class="string">'longg'</span>,<span class="string">'longe'</span>,<span class="string">'long'</span>,<span class="string">'shortg'</span>,<span class="string">'shorte'</span>,<span class="string">'short'</span>,<span class="string">'rat'</span>,<span class="string">'rational'</span>}
1802                     signmul = <span class="string">'*'</span>;
1803                     signpow = <span class="string">'^'</span>;
1804                 <span class="keyword">otherwise</span>
1805                     cformat = <span class="string">'short'</span>;
1806                     signmul = <span class="string">'*'</span>;
1807                     signpow = <span class="string">'^'</span>;
1808             <span class="keyword">end</span>
1809 
1810             <span class="comment">% check to see if its just a constant</span>
1811             <span class="keyword">if</span> isempty(<a href="#_sub28" class="code" title="subfunction vars = variables(sp)">variables</a>)  <span class="comment">% a constant only</span>
1812                 str = <a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(constant, cformat);
1813             <span class="keyword">else</span>  <span class="comment">% more than just a scalar constant</span>
1814                 str = <span class="string">''</span>;
1815 
1816                 <span class="comment">% loop over the terms in the polynomial object</span>
1817                 firstterm = true;
1818                 <span class="keyword">for</span> i = 1 : numel(coefficients)
1819                     <span class="comment">% build the multinomial part</span>
1820                     term = <span class="string">''</span>;
1821                     <span class="keyword">for</span> j = 1 : numel(<a href="#_sub28" class="code" title="subfunction vars = variables(sp)">variables</a>)
1822                         <span class="keyword">if</span> exponents(i,j)~=0
1823                             term = [term,mapvarname(<a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(<a href="#_sub28" class="code" title="subfunction vars = variables(sp)">variables</a>(j)))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1824                         <span class="keyword">end</span>
1825 
1826                         <span class="comment">% check whether explicit exponent is needed</span>
1827                         <span class="keyword">if</span> exponents(i,j)~=0 &amp;&amp; exponents(i,j)~=1
1828                             term = [term,signpow,mappower(exponents(i,j))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1829                         <span class="keyword">end</span>
1830 
1831                         <span class="comment">% insert a '*' between monomial parts</span>
1832                         <span class="keyword">if</span> ~isempty(term) &amp;&amp; j &lt; numel(<a href="#_sub28" class="code" title="subfunction vars = variables(sp)">variables</a>) &amp;&amp; any(exponents(i,(j+1):end)) &amp;&amp; ~strcmp(term(end-numel(signmul)+1:end), signmul)
1833                             term = [term,signmul]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1834                         <span class="keyword">end</span>
1835                     <span class="keyword">end</span>
1836 
1837                     C = coefficients(i);
1838                     <span class="comment">% if this is the first term, then leave the coefficient alone</span>
1839                     <span class="keyword">if</span> firstterm  <span class="comment">% this is the first term of possibly many terms</span>
1840                         <span class="keyword">if</span> C == 0
1841                             term = <span class="string">''</span>;
1842                         <span class="keyword">elseif</span> C == 1 &amp;&amp; ~isempty(term)
1843                             <span class="comment">% term is already built</span>
1844                         <span class="keyword">elseif</span> C == -1 &amp;&amp; ~isempty(term)  <span class="comment">% add unary minus</span>
1845                             term = [<span class="string">'-'</span>,term]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1846                         <span class="keyword">elseif</span> isempty(term)
1847                             term = <a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(C,cformat);
1848                         <span class="keyword">else</span>
1849                             term = [<a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(C,cformat),signmul,term]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1850                         <span class="keyword">end</span>
1851                     <span class="keyword">else</span>  <span class="comment">% there are at least two terms in the expression</span>
1852                         <span class="keyword">if</span> C == 0
1853                             term = <span class="string">''</span>;
1854                         <span class="keyword">elseif</span> C == 1 &amp;&amp; ~isempty(term)
1855                             <span class="comment">% term is already built, just append a sign</span>
1856                             term = [<span class="string">' + '</span>,term]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1857                         <span class="keyword">elseif</span> C == -1 &amp;&amp; ~isempty(term)
1858                             <span class="comment">% term is already built, just append a sign</span>
1859                             term = [<span class="string">' - '</span>,term]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1860                         <span class="keyword">elseif</span> isempty(term) &amp;&amp; (~isreal(C) || (C &gt; 0))
1861                             term = [<span class="string">' + '</span>,<a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(C,cformat)];
1862                         <span class="keyword">elseif</span> isempty(term) &amp;&amp; C &lt; 0
1863                             term = [<span class="string">' - '</span>,<a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(abs(C),cformat)];
1864                         <span class="keyword">elseif</span> ~isreal(C) || C &gt; 0
1865                             term = [<span class="string">' + '</span>,<a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(C,cformat),signmul,term]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1866                         <span class="keyword">else</span>  <span class="comment">% C &lt; 0</span>
1867                             term = [<span class="string">' - '</span>,<a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(abs(C),cformat),signmul,term]; <span class="comment">%#ok&lt;AGROW&gt;</span>
1868                         <span class="keyword">end</span>
1869                     <span class="keyword">end</span>
1870 
1871                     str = [str, term];  <span class="comment">%#ok&lt;AGROW&gt; % accumulate into the overall expression</span>
1872                     firstterm = false;  <span class="comment">% on to the rest of the terms</span>
1873                 <span class="keyword">end</span>
1874 
1875                 <span class="keyword">if</span> ~isreal(constant) || constant &gt; 0
1876                     str = [str, <span class="string">' + '</span>, <a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(constant,cformat)];
1877                 <span class="keyword">elseif</span> constant &lt; 0
1878                     str = [str, <span class="string">' - '</span>, <a href="num2string.html" class="code" title="function str = num2string(coef,cformat)">num2string</a>(abs(constant),cformat)];
1879                 <span class="keyword">end</span>
1880             <span class="keyword">end</span>
1881         <span class="keyword">end</span>
1882 
1883         <a name="_sub58" href="#_subfunctions" class="code">function str = char(sp)</a>
1884         <span class="comment">% Convert symbolic polynomial expression to a string representation.</span>
1885 
1886             <span class="keyword">if</span> isempty(sp)
1887                 str = <span class="string">''</span>;
1888                 <span class="keyword">return</span>
1889             <span class="keyword">end</span>
1890 
1891             str = <a href="#_sub58" class="code" title="subfunction str = string(sp, cformat)">string</a>(sp, get(0,<span class="string">'format'</span>));
1892         <span class="keyword">end</span>
1893 
1894         <a name="_sub59" href="#_subfunctions" class="code">function disp(sp)</a>
1895         <span class="comment">% Displays a symbolic polynomial object.</span>
1896 
1897             <span class="keyword">if</span> isempty(sp)
1898                 builtin(<span class="string">'disp'</span>, sp);
1899             <span class="keyword">elseif</span> isscalar(sp)
1900                 <a href="#_sub60" class="code" title="subfunction disp(sp)">disp</a>(<a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(sp));
1901             <span class="keyword">elseif</span> ndims(sp) == 2
1902                 arr = cell(size(sp));
1903                 <span class="keyword">for</span> j = 1 : size(sp,2)
1904                     <span class="keyword">for</span> i = 1 : size(sp,1)
1905                         arr{i,j} = <a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(sp(i,j));
1906                     <span class="keyword">end</span>
1907                 <span class="keyword">end</span>
1908                 width = max(cellfun(@length, arr), [], 1);  <span class="comment">% find largest column widths, force calculating maximum along rows</span>
1909                 <span class="keyword">for</span> i = 1 : size(sp,1)
1910                     fprintf(<span class="string">'['</span>);
1911                     <span class="keyword">for</span> j = 1 : size(sp,2)
1912                         fprintf(<span class="string">' %*s '</span>, width(j), arr{i,j});
1913                     <span class="keyword">end</span>
1914                     fprintf(<span class="string">']\n'</span>);
1915                 <span class="keyword">end</span>
1916             <span class="keyword">else</span>
1917                 fprintf(<span class="string">'[%s %s]\n'</span>, <a href="strjoin.html" class="code" title="function string = strjoin(items, adjoiner)">strjoin</a>(size(sp), <span class="string">'x'</span>), class(sp));
1918             <span class="keyword">end</span>
1919         <span class="keyword">end</span>
1920 
1921         <a name="_sub60" href="#_subfunctions" class="code">function display(sp)</a>
1922         <span class="comment">% Displays a symbolic polynomial object.</span>
1923 
1924             name = inputname(1);
1925             <span class="keyword">if</span> isempty(name)
1926                 name = <span class="string">'ans'</span>;
1927             <span class="keyword">end</span>
1928             fprintf(<span class="string">'%s =\n'</span>, name);
1929 
1930             s = size(sp);  <span class="comment">% is it a scalar or an array?</span>
1931             <span class="keyword">if</span> isempty(sp)
1932                 fprintf(<span class="string">'empty %s of size = [%s]\n'</span>, class(sp), int2str(s));
1933             <span class="keyword">elseif</span> any(s &gt; 1)  <span class="comment">% an array or vector</span>
1934                 fprintf(<span class="string">'%s array of size = [%s]\n'</span>, class(sp), int2str(s));
1935                 <span class="keyword">if</span> ndims(sp) &gt; 2
1936                     s = s(3:end);  <span class="comment">% skip first two dimensions</span>
1937                     sj = [0,ones(1,numel(s)-1)];
1938                     <span class="keyword">for</span> j = 1 : <a href="#_sub24" class="code" title="subfunction prodp = prod(sp, varargin)">prod</a>(s)
1939                         <span class="comment">% convert linear index to subscript index</span>
1940                         sj(1) = sj(1)+1;
1941                         <span class="keyword">while</span> any(sj &gt; s)
1942                             k = find(sj &gt; s, 1);  <span class="comment">% overflow in a dimension</span>
1943                             sj(k) = 1;
1944                             sj(k+1) = sj(k+1)+1;
1945                         <span class="keyword">end</span>
1946                         fprintf(<span class="string">'%s(:,:,%s) =\n'</span>, name, <a href="strjoin.html" class="code" title="function string = strjoin(items, adjoiner)">strjoin</a>(sj, <span class="string">','</span>));
1947                         <a href="#_sub60" class="code" title="subfunction disp(sp)">disp</a>(sp(:,:,j));  <span class="comment">% display two-dimensional array</span>
1948                     <span class="keyword">end</span>
1949                 <span class="keyword">else</span>
1950                     <a href="#_sub60" class="code" title="subfunction disp(sp)">disp</a>(sp);
1951                 <span class="keyword">end</span>
1952             <span class="keyword">elseif</span> isscalar(sp)  <span class="comment">% a scalar</span>
1953                 fprintf(<span class="string">'%s\n'</span>, <a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(sp));
1954             <span class="keyword">end</span>
1955         <span class="keyword">end</span>
1956     <span class="keyword">end</span>
1957     methods (Static)
1958         <a name="_sub61" href="#_subfunctions" class="code">function sp = convertpoly(p, var)</a>
1959         <span class="comment">% Create symbolic polynomial from a numeric vector of coefficients.</span>
1960         <span class="comment">%</span>
1961         <span class="comment">% Input arguments:</span>
1962         <span class="comment">% p:</span>
1963         <span class="comment">%    a vector of coefficients of a univariate polynomial in decreasing order</span>
1964         <span class="comment">%</span>
1965         <span class="comment">% See also: poly, roots</span>
1966 
1967             validateattributes(p, {<span class="string">'numeric'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'vector'</span>});
1968 
1969             p = p(:);
1970             sp = <a href="sympoly.html" class="code" title="">sympoly</a>(var);
1971             sp.Exponents = transpose(numel(p)-1:-1:1);
1972             sp.Coefficients = p(1:end-1);
1973             sp.ConstantValue = p(end);
1974             sp = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(sp);  <span class="comment">% drop powers with zero coefficient</span>
1975         <span class="keyword">end</span>
1976 
1977         <a name="_sub62" href="#_subfunctions" class="code">function sympoly_object = convertsym(sym_object)</a>
1978         <span class="comment">% Create symbolic polynomial from a sym object.</span>
1979         <span class="comment">%</span>
1980         <span class="comment">% See also: sym</span>
1981 
1982             validateattributes(sym_object, {<span class="string">'sym'</span>}, {});
1983 
1984             <span class="keyword">if</span> isscalar(sym_object)
1985                 sympoly_object = sympoly.convertscalarsym(sym_object);
1986             <span class="keyword">else</span>
1987                 sympoly_object = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(sym_object)));
1988                 <span class="keyword">for</span> k = 1 : numel(sym_object)
1989                     sympoly_object(k) = sympoly.convertscalarsym(sym_object(k));
1990                 <span class="keyword">end</span>
1991             <span class="keyword">end</span>
1992         <span class="keyword">end</span>
1993     <span class="keyword">end</span>
1994     methods (Static, Access = protected)
1995         <a name="_sub63" href="#_subfunctions" class="code">function ix = findvarinset(var, vars)</a>
1996         <span class="comment">% Find index of variable in a variable array.</span>
1997 
1998             <span class="keyword">if</span> ischar(var)
1999                 validateattributes(var, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});
2000                 ix = strmatch(var, vars, <span class="string">'exact'</span>);
2001             <span class="keyword">elseif</span> iscell(var)
2002                 validateattributes(var, {<span class="string">'cell'</span>}, {<span class="string">'size'</span>, [1 1]});
2003                 validateattributes(var{1}, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});
2004                 ix = strmatch(var, vars, <span class="string">'exact'</span>);
2005             <span class="keyword">else</span>
2006                 validateattributes(var, {<span class="string">'symvariable'</span>}, {<span class="string">'scalar'</span>});
2007                 ix = find(var == vars, 1);
2008             <span class="keyword">end</span>
2009         <span class="keyword">end</span>
2010     <span class="keyword">end</span>
2011     methods (Access = protected)
2012         <a name="_sub64" href="#_subfunctions" class="code">function ix = findvar(sp, var)</a>
2013         <span class="comment">% Find index of variable in the symbolic polynomial variable array.</span>
2014 
2015             ix = sympoly.findvarinset(var, sp.Variables);
2016         <span class="keyword">end</span>
2017 
2018         <a name="_sub65" href="#_subfunctions" class="code">function sp = sortvars(sp)</a>
2019         <span class="comment">% Sort variables in symbolic polynomial to ascending order.</span>
2020 
2021             [sp.Variables, indx] = sort(sp.Variables);  <span class="comment">% restore alphabetical (or natural) order of variables</span>
2022             sp.Exponents = sp.Exponents(:,indx);  <span class="comment">% rearrange exponent matrix to match an alphabetical order of variable names</span>
2023         <span class="keyword">end</span>
2024 
2025         <a name="_sub66" href="#_subfunctions" class="code">function [sp1,sp2] = unionvars(sp1, sp2)</a>
2026         <span class="comment">% Ensure that symbolic polynomials use the same set of variables.</span>
2027         <span class="comment">%</span>
2028         <span class="comment">% Example:</span>
2029         <span class="comment">%    [sp1,sp2] = unionvars(sp1,sp2)</span>
2030 
2031             validateattributes(sp1, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2032             validateattributes(sp2, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2033 
2034             <span class="comment">% combine the variables</span>
2035             <span class="keyword">if</span> isempty(sp2.Variables)  <span class="comment">% prevent trying to combine empty cell array with symvariable object</span>
2036                 allvars = sp1.Variables;
2037                 loc1 = 1:numel(sp1.Variables);
2038                 loc2 = [];
2039             <span class="keyword">elseif</span> isempty(sp1.Variables)
2040                 allvars = sp2.Variables;
2041                 loc1 = [];
2042                 loc2 = 1:numel(sp2.Variables);
2043             <span class="keyword">else</span>
2044                 assert(iscellstr(sp1.Variables) &amp;&amp; iscellstr(sp2.Variables) || isa(sp1.Variables, <span class="string">'symvariable'</span>) &amp;&amp; isa(sp2.Variables, <span class="string">'symvariable'</span>), <span class="keyword">...</span>
2045                     <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
2046                     <span class="string">'Mixing character variables and variables derived from symvariable is not allowed.'</span>);
2047                 <span class="comment">%allvars = union(sp1.Variables, sp2.Variables);</span>
2048                 [allvars,loc1,loc2] = <a href="merge.html" class="code" title="function [c,ia,ib] = merge(a, b)">merge</a>(sp1.Variables, sp2.Variables);
2049             <span class="keyword">end</span>
2050             numvars = numel(allvars);
2051 
2052             <span class="comment">% expand variables in sp1</span>
2053             exp1 = zeros(numel(sp1.Coefficients), numvars);
2054             <span class="keyword">if</span> ~isempty(sp1.Variables)
2055                 <span class="comment">%[~,loc1] = ismember(sp1.Variables, allvars);</span>
2056                 exp1(:,loc1) = sp1.Exponents;
2057             <span class="keyword">end</span>
2058             sp1.Variables = allvars;
2059             sp1.Exponents = exp1;
2060 
2061             <span class="comment">% expand variables in sp2</span>
2062             exp2 = zeros(numel(sp2.Coefficients), numvars);
2063             <span class="keyword">if</span> ~isempty(sp2.Variables)
2064                 <span class="comment">%[~,loc2] = ismember(sp2.Variables, allvars);</span>
2065                 exp2(:,loc2) = sp2.Exponents;
2066             <span class="keyword">end</span>
2067             sp2.Variables = allvars;
2068             sp2.Exponents = exp2;
2069         <span class="keyword">end</span>
2070 
2071         <a name="_sub67" href="#_subfunctions" class="code">function sp = clean(sp)</a>
2072         <span class="comment">% Clean up a scalar symbolic polynomial.</span>
2073         <span class="comment">% The function coalesces terms and drops excess variables.</span>
2074 
2075             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2076 
2077             <span class="keyword">if</span> numel(sp.Coefficients) &gt; 1  <span class="comment">% collect any terms that may have coalesced</span>
2078                 <span class="comment">% sort exponent vectors in ascending order</span>
2079                 [sp.Exponents,index] = sortrows(sp.Exponents);
2080 
2081                 <span class="comment">% arrange coefficients to be accumulated in same order</span>
2082                 sp.Coefficients = sp.Coefficients(index);
2083 
2084                 <span class="comment">% determine which rows are unique</span>
2085                 <span class="comment">% when subtracting neighboring rows, unique rows yield nonzero results</span>
2086                 <span class="comment">% the first row is always unique</span>
2087                 uniqueselector = [ true ; any(<a href="#_sub39" class="code" title="subfunction dpdx = diff(sp, varargin)">diff</a>(sp.Exponents), 2) ];
2088 
2089                 <span class="keyword">if</span> ~all(uniqueselector)  <span class="comment">% some exponent vectors are not unique</span>
2090                     <span class="comment">% form groups of elements, each vector element is a group index</span>
2091                     grp = cumsum(uniqueselector);
2092 
2093                     <span class="comment">% calculate run length for the groups</span>
2094                     runs = accumarray(grp,1);
2095 
2096                     <span class="comment">% add coefficients that have the same set of exponents</span>
2097                     coeff = zeros(numel(runs),1);
2098                     rs = 1;  <span class="comment">% range start index</span>
2099                     <span class="keyword">for</span> k = 1 : numel(runs)
2100                         re = rs + runs(k) - 1;  <span class="comment">% range end index</span>
2101                         coeff(k) = <a href="#_sub25" class="code" title="subfunction sump = sum(sp, varargin)">sum</a>(sp.Coefficients(rs:re));
2102                         rs = re + 1;
2103                     <span class="keyword">end</span>
2104 
2105                     <span class="comment">% drop vectors that are not unique</span>
2106                     sp.Exponents = sp.Exponents(uniqueselector,:);
2107 
2108                     <span class="comment">% set new value vector</span>
2109                     sp.Coefficients = coeff;
2110                 <span class="keyword">end</span>
2111             <span class="keyword">end</span>
2112 
2113             <span class="comment">% drop any terms with a zero coefficient, e.g. 0*x*y</span>
2114             unused = sp.Coefficients == 0;
2115             sp.Exponents(unused,:) = [];
2116             sp.Coefficients(unused,:) = [];  <span class="comment">% use two indices to keep it n-by-1 with n &gt;= 0</span>
2117 
2118             <span class="comment">% accumulate terms with all zero exponents into constant term</span>
2119             unused = all(sp.Exponents == 0, 2);
2120             sp.ConstantValue = sp.ConstantValue + <a href="#_sub25" class="code" title="subfunction sump = sum(sp, varargin)">sum</a>(sp.Coefficients(unused));
2121             sp.Exponents(unused,:) = [];
2122             sp.Coefficients(unused,:) = [];
2123 
2124             <span class="comment">% drop any variables that have all zero exponents</span>
2125             unused = all(sp.Exponents == 0, 1);
2126             sp.Variables(:,unused) = [];  <span class="comment">% use two indices to keep it 1-by-n with n &gt;= 0</span>
2127             sp.Exponents(:,unused) = [];
2128         <span class="keyword">end</span>
2129 
2130         <a name="_sub68" href="#_subfunctions" class="code">function tf = equals(lhs, rhs)</a>
2131         <span class="comment">% Test equality of a symbolic polynomial object to another or a numeric value.</span>
2132 
2133             <span class="keyword">if</span> isnumeric(rhs)  <span class="comment">% comparing a symbolic polynomial to a number</span>
2134                 consts = zeros(size(lhs));
2135                 <span class="keyword">for</span> k = 1 : numel(lhs)
2136                     <span class="keyword">if</span> ~isempty(lhs(k).Variables)
2137                         consts(k) = NaN;  <span class="comment">% polynomials that contain variables are never equal to pure constants</span>
2138                     <span class="keyword">else</span>
2139                         consts(k) = lhs(k).ConstantValue;
2140                     <span class="keyword">end</span>
2141                 <span class="keyword">end</span>
2142                 tf = consts == rhs;  <span class="comment">% fast comparison of symbolic polynomial constants with a numeric array</span>
2143             <span class="keyword">elseif</span> isa(rhs, <span class="string">'sympoly'</span>)
2144                 s1 = numel(lhs);
2145                 s2 = numel(rhs);
2146                 <span class="keyword">if</span> s1 == 1 &amp;&amp; s2 == 1  <span class="comment">% both are scalars</span>
2147                     <span class="keyword">if</span> lhs.ConstantValue ~= rhs.ConstantValue <span class="keyword">...</span>
2148                             || numel(lhs.Variables) ~= numel(rhs.Variables) <span class="keyword">...</span><span class="comment">    % not the same number of variables</span>
2149                             || numel(lhs.Coefficients) ~= numel(rhs.Coefficients)  <span class="comment">% not the same number of terms</span>
2150                         tf = false;
2151                     <span class="keyword">else</span>
2152                         <span class="keyword">if</span> iscellstr(lhs.Variables) &amp;&amp; iscellstr(rhs.Variables)
2153                             tf = all(strcmp(lhs.Variables, rhs.Variables));  <span class="comment">% variable names are always normalized to alphabetical order, can compare pairwise</span>
2154                         <span class="keyword">else</span>  <span class="comment">% symvariable object variables</span>
2155                             tf = all(lhs.Variables == rhs.Variables);  <span class="comment">% variables are sorted, can compare pairwise</span>
2156                         <span class="keyword">end</span>
2157                         tf = tf <span class="keyword">...</span>
2158                             &amp;&amp; all(lhs.Coefficients == rhs.Coefficients) <span class="keyword">...</span><span class="comment">  % coefficients are equal</span>
2159                             &amp;&amp; all(lhs.Exponents(:) == rhs.Exponents(:));     <span class="comment">% matching exponents are equal</span>
2160                     <span class="keyword">end</span>
2161                 <span class="keyword">elseif</span> s1 &gt; 1 &amp;&amp; s2 == 1  <span class="comment">% s1 is an array or vector, s2 is a scalar</span>
2162                     tf = false(size(lhs));
2163                     <span class="keyword">for</span> k = 1 : s1
2164                         tf(k) = lhs(k) == rhs;
2165                     <span class="keyword">end</span>
2166                 <span class="keyword">elseif</span> s1 == 1 &amp;&amp; s2 &gt; 1  <span class="comment">% s2 is an array or vector, s2 is a scalar</span>
2167                     tf = false(size(rhs));
2168                     <span class="keyword">for</span> k = 1 : s2
2169                         tf(k) = lhs == rhs(k);
2170                     <span class="keyword">end</span>
2171                 <span class="keyword">else</span>
2172                     assert(all(size(lhs) == size(rhs)), <span class="keyword">...</span><span class="comment">  % verify if they are compatible in size</span>
2173                         <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
2174                         <span class="string">'Comparison attempted on symbolic polynomial arrays of incompatible size.'</span>);
2175 
2176                     tf = false(size(lhs));
2177                     <span class="keyword">for</span> k = 1 : s1
2178                         tf(k) = lhs(k) == rhs(k);
2179                     <span class="keyword">end</span>
2180                 <span class="keyword">end</span>
2181             <span class="keyword">else</span>
2182                 error(<span class="string">'math:sympoly:InvalidOperation'</span>, <span class="string">'Comparison of symbolic polynomial with type &quot;%s&quot; not supported.'</span>, class(rhs));
2183             <span class="keyword">end</span>
2184         <span class="keyword">end</span>
2185 
2186         <a name="_sub69" href="#_subfunctions" class="code">function res = add(lhs, rhs)</a>
2187         <span class="comment">% Addition for symbolic polynomials.</span>
2188         <span class="comment">%</span>
2189         <span class="comment">% Input arguments:</span>
2190         <span class="comment">% lhs:</span>
2191         <span class="comment">%    a symbolic polynomial object</span>
2192         <span class="comment">% rhs:</span>
2193         <span class="comment">%    a symbolic polynomial or a numeric array</span>
2194 
2195             s1 = numel(lhs);
2196             s2 = numel(rhs);
2197             <span class="keyword">if</span> isnumeric(rhs)
2198                 <span class="keyword">if</span> s1 == 1 &amp;&amp; s2 == 1  <span class="comment">% both are scalars</span>
2199                     res = lhs;
2200                     res.ConstantValue = res.ConstantValue + rhs;
2201                 <span class="keyword">elseif</span> s1 &gt; 1 &amp;&amp; s2 == 1  <span class="comment">% s1 is an array or vector, s2 is a scalar</span>
2202                     res = lhs;
2203                     <span class="keyword">for</span> k = 1 : numel(res)
2204                         res(k).ConstantValue = res(k).ConstantValue + rhs;
2205                     <span class="keyword">end</span>
2206                 <span class="keyword">elseif</span> s1 == 1 &amp;&amp; s2 &gt; 1  <span class="comment">% s2 is an array or vector, s1 is a scalar</span>
2207                     res = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(rhs)));
2208                     res(:) = lhs;
2209                     <span class="keyword">for</span> k = 1 : numel(res)
2210                         res(k).ConstantValue = res(k).ConstantValue + rhs(k);
2211                     <span class="keyword">end</span>
2212                 <span class="keyword">else</span>  <span class="comment">% s1 &gt; 1 &amp;&amp; s2 &gt; 1  % s1 and s2 are both arrays or vectors</span>
2213                     assert(all(size(lhs) == size(rhs)), <span class="keyword">...</span><span class="comment">  % verify if they are compatible in size</span>
2214                         <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
2215                         <span class="string">'Addition of symbolic polynomial array and numeric array of incompatible size.'</span>);
2216 
2217                     res = lhs;
2218                     <span class="keyword">for</span> k = 1 : numel(res)
2219                         res(k).ConstantValue = res(k).ConstantValue + rhs(k);
2220                     <span class="keyword">end</span>
2221                 <span class="keyword">end</span>
2222             <span class="keyword">elseif</span> isa(rhs, <span class="string">'sympoly'</span>)
2223                 <span class="keyword">if</span> s1 == 1 &amp;&amp; s2 == 1  <span class="comment">% both are scalars</span>
2224                     [lhs,rhs] = <a href="#_sub67" class="code" title="subfunction [sp1,sp2] = unionvars(sp1, sp2)">unionvars</a>(lhs,rhs);  <span class="comment">% make sure they have compatible variable sets</span>
2225 
2226                     <span class="comment">% addition requires appending the arrays, then a consolidation step</span>
2227                     res = <a href="sympoly.html" class="code" title="">sympoly</a>;
2228                     res.Variables = lhs.Variables;
2229                     res.Exponents = [lhs.Exponents;rhs.Exponents];
2230                     res.Coefficients = [lhs.Coefficients;rhs.Coefficients];
2231                     res.ConstantValue = lhs.ConstantValue + rhs.ConstantValue;
2232                     res = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(res);  <span class="comment">% clean up the polynomial</span>
2233                 <span class="keyword">elseif</span> s1 &gt; 1 &amp;&amp; s2 == 1  <span class="comment">% s1 is an array or vector, s2 is a scalar</span>
2234                     res = lhs;
2235                     <span class="keyword">for</span> k = 1 : s1
2236                         res(k) = <a href="#_sub70" class="code" title="subfunction res = add(lhs, rhs)">add</a>(res(k), rhs);
2237                     <span class="keyword">end</span>
2238                 <span class="keyword">elseif</span> s1 == 1 &amp;&amp; s2 &gt; 1  <span class="comment">% s2 is an array or vector, s1 is a scalar</span>
2239                     res = rhs;
2240                     <span class="keyword">for</span> k = 1 : s2
2241                         res(k) = <a href="#_sub70" class="code" title="subfunction res = add(lhs, rhs)">add</a>(lhs, res(k));
2242                     <span class="keyword">end</span>
2243                 <span class="keyword">else</span>  <span class="comment">% s1 &gt; 1 &amp;&amp; s2 &gt; 1  % s1 and s2 are both arrays or vectors</span>
2244                     assert(all(size(lhs) == size(rhs)), <span class="keyword">...</span><span class="comment">  % verify if they are compatible in size</span>
2245                         <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
2246                         <span class="string">'Addition of symbolic polynomial arrays of incompatible size.'</span>);
2247 
2248                     <span class="comment">% add elementwise</span>
2249                     res = lhs;
2250                     <span class="keyword">for</span> k = 1 : s1
2251                         res(k) = <a href="#_sub70" class="code" title="subfunction res = add(lhs, rhs)">add</a>(res(k), rhs(k));
2252                     <span class="keyword">end</span>
2253                 <span class="keyword">end</span>
2254             <span class="keyword">end</span>
2255         <span class="keyword">end</span>
2256 
2257         <a name="_sub70" href="#_subfunctions" class="code">function res = multiply(lhs, rhs)</a>
2258         <span class="comment">% Elementwise multiplication for symbolic polynomials.</span>
2259         <span class="comment">%</span>
2260         <span class="comment">% Input arguments:</span>
2261         <span class="comment">% sp1, sp2:</span>
2262         <span class="comment">%    a symbolic polynomial or a numeric array</span>
2263 
2264             s1 = numel(lhs);
2265             s2 = numel(rhs);
2266             <span class="keyword">if</span> isnumeric(rhs)
2267                 <span class="keyword">if</span> s1 == 1 &amp;&amp; s2 == 1  <span class="comment">% both are scalars</span>
2268                     <span class="keyword">if</span> rhs ~= 0
2269                         res = lhs;
2270                         res.Coefficients = res.Coefficients .* rhs;
2271                         res.ConstantValue = res.ConstantValue .* rhs;
2272                     <span class="keyword">else</span>  <span class="comment">% multiplication by zero</span>
2273                         res = <a href="sympoly.html" class="code" title="">sympoly</a>(0);
2274                     <span class="keyword">end</span>
2275                 <span class="keyword">elseif</span> s1 &gt; 1 &amp;&amp; s2 == 1  <span class="comment">% s1 is an array or vector, s2 is a scalar</span>
2276                     res = lhs;
2277                     <span class="keyword">for</span> k = 1 : numel(res)
2278                         res(k).Coefficients = res(k).Coefficients .* rhs;
2279                         res(k).ConstantValue = res(k).ConstantValue .* rhs;
2280                     <span class="keyword">end</span>
2281                 <span class="keyword">elseif</span> s1 == 1 &amp;&amp; s2 &gt; 1  <span class="comment">% s2 is an array or vector, s1 is a scalar</span>
2282                     res = <a href="sympoly.html" class="code" title="">sympoly</a>(zeros(size(rhs)));
2283                     res(:) = lhs;
2284                     <span class="keyword">for</span> k = 1 : numel(res)
2285                         res(k).Coefficients = res(k).Coefficients .* rhs(k);
2286                         res(k).ConstantValue = res(k).ConstantValue .* rhs(k);
2287                     <span class="keyword">end</span>
2288                 <span class="keyword">else</span>  <span class="comment">% s1 &gt; 1 &amp;&amp; s2 &gt; 1  % s1 and s2 are both arrays or vectors</span>
2289                     assert(all(size(lhs) == size(rhs)), <span class="keyword">...</span><span class="comment">  % verify if they are compatible in size</span>
2290                         <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
2291                         <span class="string">'Multiplication of symbolic polynomial array and numeric array of incompatible size.'</span>);
2292 
2293                     res = lhs;
2294                     <span class="keyword">for</span> k = 1 : numel(res)
2295                         res(k).Coefficients = res(k).Coefficients .* rhs(k);
2296                         res(k).ConstantValue = res(k).ConstantValue .* rhs(k);
2297                     <span class="keyword">end</span>
2298                 <span class="keyword">end</span>
2299             <span class="keyword">elseif</span> isa(rhs, <span class="string">'sympoly'</span>)
2300                 <span class="keyword">if</span> s1 == 1 &amp;&amp; s2 == 1  <span class="comment">% both are scalars</span>
2301                     [lhs,rhs] = <a href="#_sub67" class="code" title="subfunction [sp1,sp2] = unionvars(sp1, sp2)">unionvars</a>(lhs,rhs);  <span class="comment">% make sure they have compatible variable lists</span>
2302 
2303                     n1 = numel(lhs.Coefficients);
2304                     n2 = numel(rhs.Coefficients);
2305                     nv = numel(lhs.Variables);
2306 
2307                     res = <a href="sympoly.html" class="code" title="">sympoly</a>;
2308                     res.Variables = lhs.Variables;
2309                     res.Exponents = zeros(n1*n2+n1+n2,nv);
2310                     res.Coefficients = zeros(n1*n2+n1+n2,1);
2311                     <span class="keyword">for</span> i = 1 : n1
2312                         res.Exponents(1 + (i-1)*n2 : n2 + (i-1)*n2, :) = bsxfun(@<a href="#_sub11" class="code" title="subfunction sp = plus(sp1, sp2)">plus</a>, rhs.Exponents, lhs.Exponents(i,:));
2313                         res.Coefficients(1 + (i-1)*n2 : n2 + (i-1)*n2, 1) = rhs.Coefficients * lhs.Coefficients(i,1);
2314                     <span class="keyword">end</span>
2315                     res.Exponents(1 + n1*n2 : n1+n2 + n1*n2, :) = [ lhs.Exponents ; rhs.Exponents ];
2316                     res.Coefficients(1 + n1*n2 : n1+n2 + n1*n2) = [ lhs.Coefficients * rhs.ConstantValue ; rhs.Coefficients * lhs.ConstantValue ];
2317                     res.ConstantValue = lhs.ConstantValue * rhs.ConstantValue;
2318                     res = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(res);  <span class="comment">% clean up the polynomial</span>
2319                 <span class="keyword">elseif</span> s1 &gt; 1 &amp;&amp; s2 == 1  <span class="comment">% s1 is an array or vector, s2 is a scalar</span>
2320                     res = lhs;
2321                     <span class="keyword">for</span> k = 1 : s1
2322                         res(k) = <a href="#_sub71" class="code" title="subfunction res = multiply(lhs, rhs)">multiply</a>(res(k), rhs);
2323                     <span class="keyword">end</span>
2324                 <span class="keyword">elseif</span> s1 == 1 &amp;&amp; s2 &gt; 1  <span class="comment">% s2 is an array or vector, s1 is a scalar</span>
2325                     res = rhs;
2326                     <span class="keyword">for</span> k = 1 : s2
2327                         res(k) = <a href="#_sub71" class="code" title="subfunction res = multiply(lhs, rhs)">multiply</a>(lhs, res(k));
2328                     <span class="keyword">end</span>
2329                 <span class="keyword">else</span>  <span class="comment">% s1 &gt; 1 &amp;&amp; s2 &gt; 1  % s1 and s2 are both arrays or vectors</span>
2330                     assert(all(size(lhs) == size(rhs)), <span class="keyword">...</span><span class="comment">  % verify if they are compatible in size</span>
2331                         <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
2332                         <span class="string">'Multiplication of symbolic polynomial arrays of incompatible size.'</span>);
2333 
2334                     <span class="comment">% multiply elementwise</span>
2335                     res = lhs;
2336                     <span class="keyword">for</span> k = 1 : s1
2337                         res(k) = <a href="#_sub71" class="code" title="subfunction res = multiply(lhs, rhs)">multiply</a>(res(k), rhs(k));
2338                     <span class="keyword">end</span>
2339                 <span class="keyword">end</span>
2340             <span class="keyword">end</span>
2341         <span class="keyword">end</span>
2342 
2343         <a name="_sub71" href="#_subfunctions" class="code">function sp = scalardivide(sp1, sp2)</a>
2344         <span class="comment">% Elementwise division for scalar symbolic polynomials.</span>
2345         <span class="comment">%</span>
2346         <span class="comment">% Input arguments:</span>
2347         <span class="comment">% sp1, sp2:</span>
2348         <span class="comment">%    a symbolic polynomial</span>
2349 
2350             <span class="keyword">if</span> <a href="#_sub29" class="code" title="subfunction tf = isconstant(sp)">isconstant</a>(sp2)  <span class="comment">% e.g. sympoly(2)</span>
2351                 sp = sp1;
2352                 sp.Coefficients = sp.Coefficients ./ sp2.ConstantValue;
2353                 sp.ConstantValue = sp.ConstantValue ./ sp2.ConstantValue;
2354             <span class="keyword">elseif</span> <a href="#_sub32" class="code" title="subfunction tf = ismonomial(sp)">ismonomial</a>(sp2)  <span class="comment">% e.g. 2*x^4</span>
2355                 <span class="comment">% inverse of monomial: 2*x^4 --&gt; 0.5*x^-4</span>
2356                 sp2.Exponents = -sp2.Exponents;
2357                 sp2.Coefficients = 1 ./ sp2.Coefficients;
2358 
2359                 <span class="comment">% multiply with inverse</span>
2360                 sp = sp1 .* sp2;
2361             <span class="keyword">else</span>
2362                 [sp,sprem,remflag] = <a href="#_sub73" class="code" title="subfunction [q,r,rflag] = longdivide(lhs, rhs)">longdivide</a>(sp1, sp2);
2363                 assert(~remflag, <span class="keyword">...</span>
2364                     <span class="string">'math:sympoly:NonzeroRemainder'</span>, <span class="keyword">...</span>
2365                     <span class="string">'Polynomial division of %s with %s resulted in nonzero remainder %s.'</span>, <a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(sp1), <a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(sp2), <a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(sprem));
2366             <span class="keyword">end</span>
2367         <span class="keyword">end</span>
2368 
2369         <a name="_sub72" href="#_subfunctions" class="code">function [q,r,rflag] = longdivide(lhs, rhs)</a>
2370         <span class="comment">% Polynomial long division.</span>
2371 
2372             <span class="keyword">if</span> <a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(lhs) &amp;&amp; <a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(rhs)
2373                 assert(all(lhs.Exponents == floor(lhs.Exponents)) &amp;&amp; all(rhs.Exponents == floor(rhs.Exponents)), <span class="keyword">...</span>
2374                     <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
2375                     <span class="string">'Fractional exponents are not supported.'</span>);
2376                 var = <a href="#_sub85" class="code" title="subfunction var = univariatesym(sp)">univariatesym</a>(lhs);
2377 
2378                 <span class="comment">% normalize lowest degree to 0</span>
2379                 <span class="keyword">if</span> isempty(lhs.Exponents)
2380                     lm = 0;
2381                 <span class="keyword">else</span>
2382                     lm = min(lhs.Exponents);
2383                     <span class="keyword">if</span> lm &gt; 0 &amp;&amp; lhs.ConstantValue ~= 0
2384                         lm = 0;
2385                     <span class="keyword">end</span>
2386                 <span class="keyword">end</span>
2387                 <span class="keyword">if</span> isempty(rhs.Exponents)
2388                     rm = 0;
2389                 <span class="keyword">else</span>
2390                     rm = min(rhs.Exponents);
2391                     <span class="keyword">if</span> rm &gt; 0 &amp;&amp; rhs.ConstantValue ~= 0
2392                         rm = 0;
2393                     <span class="keyword">end</span>
2394                 <span class="keyword">end</span>
2395                 m = min(lm,rm);
2396 
2397                 <span class="comment">% convert symbolic polynomial to numeric vector of coefficients</span>
2398                 lhsp = zeros(max(lhs.Exponents)-m+1, 1);  <span class="comment">% use column vectors</span>
2399                 lhsp(end) = lhs.ConstantValue;
2400                 lhsp(end-lhs.Exponents+m) = lhs.Coefficients;
2401                 rhsp = zeros(max(rhs.Exponents)-m+1, 1);
2402                 rhsp(end) = rhs.ConstantValue;
2403                 rhsp(end-rhs.Exponents+m) = rhs.Coefficients;
2404 
2405                 <span class="comment">% perform deconvolution</span>
2406                 [qp,rp] = deconv(lhsp,rhsp);  <span class="comment">% returns column vectors</span>
2407 
2408                 <span class="comment">% create sympoly objects</span>
2409                 q = <a href="sympoly.html" class="code" title="">sympoly</a>(var);  <span class="comment">% univariate</span>
2410                 q.Exponents = transpose(numel(qp)-1:-1:0);  <span class="comment">% greatest common power m canceled</span>
2411                 q.Coefficients = qp;
2412                 q = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(q);  <span class="comment">% drop powers with zero coefficient and normalize coefficients with all-zero powers</span>
2413                 r = <a href="sympoly.html" class="code" title="">sympoly</a>(var);
2414                 r.Exponents = transpose(numel(rp)-1+m:-1:m);  <span class="comment">% reverse normalization by m</span>
2415                 r.Coefficients = rp;
2416                 r = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(r);
2417 
2418                 rflag = numel(rp) ~= 1 || rp ~= 0;
2419             <span class="keyword">elseif</span> <a href="#_sub30" class="code" title="subfunction tf = islinear(sp)">islinear</a>(sp2)
2420                 [q,r,rflag] = <a href="#_sub74" class="code" title="subfunction [q,r,rflag] = syntheticdivide(lhs, rhs) ">syntheticdivide</a>(lhs, rhs);
2421             <span class="keyword">else</span>
2422                 error(<span class="string">'math:sympoly:NotSupported'</span>, <span class="string">'Division with nonlinear or polyvariate divisor is not supported.'</span>);
2423             <span class="keyword">end</span>
2424         <span class="keyword">end</span>
2425 
2426         <a name="_sub73" href="#_subfunctions" class="code">function [q,r,rflag] = syntheticdivide(lhs, rhs) </a><span class="comment">%#ok&lt;STOUT,MANU&gt;</span>
2427         <span class="comment">% Synthetic division with non-degenerate linear univariate term.</span>
2428 
2429             assert(~<a href="#_sub29" class="code" title="subfunction tf = isconstant(sp)">isconstant</a>(rhs) &amp;&amp; ~<a href="#_sub32" class="code" title="subfunction tf = ismonomial(sp)">ismonomial</a>(rhs), <span class="keyword">...</span>
2430                 <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
2431                 <span class="string">'Synthetic division requires a non-degenerate linear term of the form x + c'</span>);
2432 
2433             error(<span class="string">'math:sympoly:NotImplemented'</span>, <span class="string">'Synthetic division of polyvariate polynomials is not yet implemented.'</span>);
2434         <span class="keyword">end</span>
2435 
2436         <a name="_sub74" href="#_subfunctions" class="code">function dpdx = differentiate(sp, n, dvar)</a>
2437         <span class="comment">% Derivative of a scalar symbolic polynomial.</span>
2438 
2439             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2440             validateattributes(n, {<span class="string">'numeric'</span>}, {<span class="string">'nonnegative'</span>,<span class="string">'integer'</span>,<span class="string">'scalar'</span>});
2441 
2442             <span class="keyword">if</span> n == 0
2443                 dpdx = sp;  <span class="comment">% do nothing</span>
2444                 <span class="keyword">return</span>;
2445             <span class="keyword">elseif</span> n &gt; 1
2446                 <span class="comment">% recursive calls for higher-order differentiation</span>
2447                 dpdx = sp;
2448                 <span class="keyword">for</span> k = 1 : n
2449                     dpdx = <a href="#_sub75" class="code" title="subfunction dpdx = differentiate(sp, n, dvar)">differentiate</a>(dpdx, 1, dvar);
2450                 <span class="keyword">end</span>
2451                 <span class="keyword">return</span>;
2452             <span class="keyword">end</span>
2453 
2454             indx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp, dvar);  <span class="comment">% is sp a function of the designated variable?</span>
2455             <span class="keyword">if</span> isempty(indx)
2456                 dpdx = <a href="sympoly.html" class="code" title="">sympoly</a>(0);  <span class="comment">% sp is not a function of that variable, so the derivative will be zero</span>
2457             <span class="keyword">else</span>
2458                 <span class="comment">% perform actual differentiation</span>
2459                 dpdx = sp;
2460                 pow = sp.Exponents(:,indx);
2461 
2462                 <span class="comment">% drop terms where variable has zero power</span>
2463                 dpdx.Exponents(pow==0,:) = [];
2464                 dpdx.Coefficients(pow==0) = [];
2465                 dpdx.ConstantValue = 0;
2466                 pow(pow==0) = [];
2467 
2468                 <span class="keyword">if</span> isempty(pow)  <span class="comment">% the derivative is totally zero</span>
2469                     dpdx = <a href="sympoly.html" class="code" title="">sympoly</a>(0);
2470                 <span class="keyword">else</span>  <span class="comment">% there are some terms that remain</span>
2471                     dpdx.Exponents(:,indx) = pow-1;
2472                     dpdx.Coefficients = dpdx.Coefficients.*pow;
2473 
2474                     <span class="comment">% clean up the polynomial</span>
2475                     dpdx = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(dpdx);  <span class="comment">% rows with all-zero exponents become constants with gargbage collection and normalization</span>
2476                 <span class="keyword">end</span>
2477             <span class="keyword">end</span>
2478         <span class="keyword">end</span>
2479 
2480         <a name="_sub75" href="#_subfunctions" class="code">function sp = substitute(sp, old, new)</a>
2481         <span class="comment">% Substitute symbolic term in place of other symbolic term.</span>
2482 
2483             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2484             validateattributes(old, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2485             validateattributes(new, {<span class="string">'sympoly'</span>,<span class="string">'numeric'</span>}, {<span class="string">'scalar'</span>});
2486 
2487             assert(<a href="#_sub32" class="code" title="subfunction tf = ismonomial(sp)">ismonomial</a>(old), <span class="keyword">...</span>
2488                 <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
2489                 <span class="string">'Substitution expects a univariate monomial to substitute for.'</span>);
2490 
2491             <span class="comment">% is the symbolic polynomial a function of this variable?</span>
2492             vindx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp, old.Variables);  <span class="comment">% index of the variable to substitute for in the expression</span>
2493             <span class="keyword">if</span> isempty(vindx)
2494                 <span class="keyword">return</span>;  <span class="comment">% nothing to substitute</span>
2495             <span class="keyword">end</span>
2496 
2497             <span class="comment">% is &quot;new&quot; a sympoly itself or numeric?</span>
2498             <span class="keyword">if</span> isnumeric(new)  <span class="comment">% a number, the substitution is easy</span>
2499                 tindx = find(sp.Exponents(:,vindx));  <span class="comment">% indices of terms where the variable had nonzero exponent</span>
2500                 pow = sp.Exponents(tindx,vindx);
2501                 sp.Coefficients(tindx) = sp.Coefficients(tindx) ./ old.Coefficients .* new.^(pow ./ old.Exponents);  <span class="comment">% compensate with exponent of the substituted variable</span>
2502                 sp.Exponents(:,vindx) = 0;
2503                 sp = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(sp);  <span class="comment">% clean it all up</span>
2504             <span class="keyword">elseif</span> <a href="#_sub32" class="code" title="subfunction tf = ismonomial(sp)">ismonomial</a>(new)
2505                 windx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp, new.Variables);  <span class="comment">% test whether the expression already contains the variable to substitue</span>
2506 
2507                 <span class="keyword">if</span> isempty(windx) || windx ~= vindx  <span class="comment">% new variable not in expression</span>
2508                     sp.Variables(vindx) = new.Variables;  <span class="comment">% replace variable</span>
2509                 <span class="keyword">end</span>
2510 
2511                 tindx = find(sp.Exponents(:,vindx));  <span class="comment">% indices of terms where the variable to replace had nonzero exponent</span>
2512                 <span class="keyword">if</span> isempty(tindx)  <span class="comment">% a degenerate polynomial, the polynomial is not a function of the variable</span>
2513                     <span class="keyword">return</span>;
2514                 <span class="keyword">end</span>
2515 
2516                 pow = sp.Exponents(tindx,vindx);
2517                 sp.Coefficients(tindx) = sp.Coefficients(tindx) ./ old.Coefficients .* new.Coefficients.^(pow ./ old.Exponents);
2518                 sp.Exponents(:,vindx) = sp.Exponents(:,vindx) ./ old.Exponents .* new.Exponents;
2519 
2520                 <span class="keyword">if</span> isempty(windx)
2521                     <span class="comment">% variable to substitute overwrites a previous variable</span>
2522                     <span class="comment">% e.g. y --&gt; z^2 in x^2 + y^3 --&gt; x^2 + z^6</span>
2523                     sp = <a href="#_sub66" class="code" title="subfunction sp = sortvars(sp)">sortvars</a>(sp);
2524                 <span class="keyword">elseif</span> windx ~= vindx
2525                     <span class="comment">% variable to substitute is already in expression</span>
2526                     <span class="comment">% e.g. y --&gt; x^2 in x^2 + y^3 --&gt; x^2 + x^6</span>
2527                     sp.Exponents(:,windx) = sp.Exponents(:,windx) + sp.Exponents(:,vindx);  <span class="comment">% contract exponent matrix</span>
2528                     sp.Exponents(:,vindx) = [];  <span class="comment">% delete overwritten variable (e.g. y), located replacement variable is guaranteed to be in order, no order restoration needed</span>
2529                     sp.Variables(:,vindx) = [];  <span class="comment">% two indices ensure proper structure even for zero variables</span>
2530                 <span class="keyword">end</span>
2531             <span class="keyword">else</span>  <span class="comment">% a general symbolic polynomial, hard way</span>
2532                 assert(old.Coefficients == 1, <span class="keyword">...</span>
2533                     <span class="string">'math:sympoly:ArgumentTypeMismatch'</span>, <span class="keyword">...</span>
2534                     <span class="string">'Substitution expects a univariate monomial with unit coefficient to substitute for.'</span>);
2535 
2536                 spsubs = <a href="sympoly.html" class="code" title="">sympoly</a>(0);
2537                 nc = length(sp.Coefficients);
2538                 <span class="keyword">for</span> i = 1 : nc  <span class="comment">% enumerate terms</span>
2539                     coeff = sp.Coefficients(i);  <span class="comment">% extract coefficient from term</span>
2540                     expon = sp.Exponents(i,:);   <span class="comment">% extract exponent of variable to substitute for</span>
2541                     pow = expon(1,vindx);        <span class="comment">% save old value of exponent</span>
2542                     expon(1,vindx) = 0;          <span class="comment">% remove variable to substitute for from the expression</span>
2543 
2544                     <span class="comment">% build new term with substituted expression</span>
2545                     spi = <a href="sympoly.html" class="code" title="">sympoly</a>(0);
2546                     spi.Coefficients = coeff;
2547                     spi.Variables = sp.Variables;
2548                     spi.Exponents = expon;
2549                     spi = spi .* new.^(pow ./ old.Exponents);  <span class="comment">% compensate for original exponent</span>
2550                     spsubs = spsubs + spi;  <span class="comment">% automatically performs garbage collection</span>
2551                 <span class="keyword">end</span>
2552                 spsubs = spsubs + sp.ConstantValue;
2553                 sp = spsubs;
2554             <span class="keyword">end</span>
2555         <span class="keyword">end</span>
2556 
2557         <a name="_sub76" href="#_subfunctions" class="code">function sp = substitutepower(sp, old, new)</a>
2558         <span class="comment">% Substitute exact power of a variable into symbolic polynomial.</span>
2559 
2560             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2561             validateattributes(old, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2562             validateattributes(new, {<span class="string">'sympoly'</span>, <span class="string">'numeric'</span>}, {<span class="string">'scalar'</span>});
2563 
2564             assert(<a href="#_sub32" class="code" title="subfunction tf = ismonomial(sp)">ismonomial</a>(old), <span class="keyword">...</span>
2565                 <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
2566                 <span class="string">'Substitution expects a univariate monomial to substitute for.'</span>);
2567 
2568             <span class="comment">% is the symbolic polynomial a function of this variable?</span>
2569             vindx = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(sp, old.Variables);  <span class="comment">% index of the variable to substitute for in the expression</span>
2570             <span class="keyword">if</span> isempty(vindx)
2571                 <span class="keyword">return</span>;
2572             <span class="keyword">end</span>
2573 
2574             <span class="comment">% create a temporary symbolic polynomial in which only those terms with specified power of the variable occur</span>
2575             tindx = sp.Exponents(:,vindx) == old.Exponents;
2576 
2577             <span class="keyword">if</span> any(tindx)  <span class="comment">% some terms contain the variable raised to the specified power</span>
2578                 temp = sp;
2579                 temp.Exponents(~tindx,vindx) = 0;  <span class="comment">% clear those terms that have the variable with a different power</span>
2580                 temp.Coefficients(~tindx) = 0;
2581                 temp = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(temp);
2582                 temp = <a href="#_sub76" class="code" title="subfunction sp = substitute(sp, old, new)">substitute</a>(temp, old, new);
2583                 sp.Exponents(tindx,vindx) = 0;  <span class="comment">% clear those terms in which the substitutes come from temp</span>
2584                 sp.Coefficients(tindx) = 0;
2585                 sp = sp + temp;
2586             <span class="keyword">end</span>
2587         <span class="keyword">end</span>
2588 
2589         <a name="_sub77" href="#_subfunctions" class="code">function polymean = errormean(sp, vars, means, stds)</a>
2590         <span class="comment">% Symbolic mean given normal components.</span>
2591         <span class="comment">%</span>
2592         <span class="comment">% See also: sympoly.errorprop</span>
2593 
2594             polymean = sp;
2595             nvars = numel(vars);
2596 
2597             <span class="comment">% substitute unit normal variables into the polynomial computing the mean</span>
2598             <span class="keyword">for</span> i = 1 : nvars
2599                 <span class="comment">% substitute x_i = means(i) + stds(i) * u</span>
2600                 tempvarname = [<span class="string">'__'</span>, <a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(vars{i}), <span class="string">'__'</span>];
2601                 <span class="keyword">if</span> isa(vars{i}, <span class="string">'symvariable'</span>)
2602                     tempvar = copy(vars{i}, tempvarname);
2603                 <span class="keyword">else</span>  <span class="comment">% variable as string</span>
2604                     tempvar = tempvarname;
2605                 <span class="keyword">end</span>
2606                 polymean = <a href="#_sub48" class="code" title="subfunction sp = subs(sp, old, new)">subs</a>(polymean, vars{i}, means(i) + stds(i)*<a href="sympoly.html" class="code" title="">sympoly</a>(tempvar));
2607 
2608                 <span class="comment">% which variable was tempvar in polymean?</span>
2609                 k = <a href="#_sub65" class="code" title="subfunction ix = findvar(sp, var)">findvar</a>(polymean, tempvar);
2610 
2611                 <span class="comment">% for a unit normal variates, the kth central moment is</span>
2612                 <span class="comment">% * zero                    for the odd moments</span>
2613                 <span class="comment">% * fact(2*k)/(2^k*fact(k)) for the even moments</span>
2614 
2615                 <span class="comment">% delete all the terms in polymean with an odd exponent</span>
2616                 oddexp = mod(polymean.Exponents(:,k),2) == 1;
2617                 <span class="keyword">if</span> any(oddexp)
2618                     polymean.Exponents(oddexp,:) = [];
2619                     polymean.Coefficients(oddexp) = [];
2620                 <span class="keyword">end</span>
2621 
2622                 <span class="comment">% compute even moments.</span>
2623                 evenexp = polymean.Exponents(:,k) / 2;
2624                 <span class="keyword">if</span> any(evenexp)
2625                     varmoment = factorial(2*evenexp)./(2.^evenexp.*factorial(evenexp));
2626                     polymean.Coefficients = polymean.Coefficients.*varmoment;
2627                 <span class="keyword">end</span>
2628 
2629                 <span class="comment">% eliminate temporary variable</span>
2630                 polymean.Exponents(:,k) = 0;
2631 
2632                 <span class="comment">% perform cleanup</span>
2633                 polymean = <a href="#_sub68" class="code" title="subfunction sp = clean(sp)">clean</a>(polymean);
2634             <span class="keyword">end</span>
2635         <span class="keyword">end</span>
2636 
2637         <a name="_sub78" href="#_subfunctions" class="code">function [expr,vars] = symobject(sp)</a>
2638         <span class="comment">% Convert symbolic polynomial scalar to Symbolic Toolbox sym object.</span>
2639         <span class="comment">%</span>
2640         <span class="comment">% See also: sym</span>
2641 
2642             vars = <a href="#_sub55" class="code" title="subfunction [expr,vars] = sym(sp)">sym</a>(zeros(1,numel(sp.Variables)));
2643             <span class="keyword">for</span> k = 1 : numel(sp.Variables)  <span class="comment">% create Symbolic Toolbox symbolic variables</span>
2644                 vars(k) = <a href="#_sub55" class="code" title="subfunction [expr,vars] = sym(sp)">sym</a>(<a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(sp.Variables(k)));
2645             <span class="keyword">end</span>
2646 
2647             expr = <a href="#_sub55" class="code" title="subfunction [expr,vars] = sym(sp)">sym</a>(sp.ConstantValue);
2648             <span class="keyword">for</span> i = 1 : numel(sp.Coefficients)  <span class="comment">% iterate over terms</span>
2649                 <span class="keyword">if</span> sp.Coefficients(i) ~= 0  <span class="comment">% omit terms with zero coefficient</span>
2650                     term = <a href="#_sub55" class="code" title="subfunction [expr,vars] = sym(sp)">sym</a>(sp.Coefficients(i));
2651                     <span class="keyword">for</span> j = 1 : numel(sp.Variables)  <span class="comment">% iterate over variables in a term</span>
2652                         <span class="keyword">if</span> sp.Exponents(i,j) ~= 0  <span class="comment">% omit variables with zero exponent</span>
2653                             term = term * vars(j)^sp.Exponents(i,j);
2654                         <span class="keyword">end</span>
2655                     <span class="keyword">end</span>
2656 
2657                     expr = expr + term;
2658                 <span class="keyword">end</span>
2659             <span class="keyword">end</span>
2660         <span class="keyword">end</span>
2661 
2662         <a name="_sub79" href="#_subfunctions" class="code">function str = formatmatrix(sp, fun, colsep, rowsep, linesep, open, close)</a>
2663         <span class="comment">% Format a matrix of polynomials according to the given specifications.</span>
2664         <span class="comment">%</span>
2665         <span class="comment">% Input arguments:</span>
2666         <span class="comment">% fun:</span>
2667         <span class="comment">%    a function to apply to all elements of the array that converts an entry</span>
2668         <span class="comment">%    into a string, e.g. @(elem) char(elem)</span>
2669         <span class="comment">% colsep:</span>
2670         <span class="comment">%    separates columns in a matrix, e.g. ','</span>
2671         <span class="comment">% rowsep:</span>
2672         <span class="comment">%    separates rows in matrix, e.g. ';'</span>
2673         <span class="comment">% open:</span>
2674         <span class="comment">%    starts the matrix expression, e.g. '['</span>
2675         <span class="comment">% close:</span>
2676         <span class="comment">%    ends the matrix expression, e.g. ']'</span>
2677 
2678             validateattributes(fun, {<span class="string">'function_handle'</span>}, {<span class="string">'scalar'</span>});
2679             validateattributes(colsep, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});
2680             validateattributes(rowsep, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});
2681             validateattributes(linesep, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});
2682             validateattributes(<a href="../../../src/@RemoteControlBoardRemapper/open.html" class="code" title="function open(obj,partList,jointsList)">open</a>, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});
2683             validateattributes(close, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});
2684 
2685             <span class="keyword">if</span> isscalar(sp)
2686                 str = fun(sp);
2687             <span class="keyword">elseif</span> isvector(sp)
2688                 <span class="keyword">if</span> size(sp,1) &gt; size(sp,2)  <span class="comment">% column vector</span>
2689                     sep = rowsep;
2690                 <span class="keyword">else</span>
2691                     sep = colsep;
2692                 <span class="keyword">end</span>
2693                 strs = cell(1, numel(sp) + 1);
2694                 k = 1;
2695                 strs{k} = sprintf(<span class="string">'%s %s'</span>, <a href="../../../src/@RemoteControlBoardRemapper/open.html" class="code" title="function open(obj,partList,jointsList)">open</a>, fun(sp(1)));
2696                 <span class="keyword">for</span> i = 2 : numel(sp)
2697                     k = k + 1;
2698                     strs{k} = sprintf(<span class="string">'%s %s'</span>, sep, fun(sp(i)));
2699                 <span class="keyword">end</span>
2700                 k = k + 1;
2701                 strs{k} = sprintf(<span class="string">' %s'</span>, close);
2702                 str = cell2mat(strs);  <span class="comment">% join strings into a single string</span>
2703             <span class="keyword">elseif</span> ~isempty(sp) &amp;&amp; ndims(sp) &lt;= 2
2704                 arr = cell(size(sp));
2705                 <span class="keyword">for</span> j = 1 : size(sp,2)
2706                     <span class="keyword">for</span> i = 1 : size(sp,1)
2707                         arr{i,j} = fun(sp(i,j));
2708                     <span class="keyword">end</span>
2709                 <span class="keyword">end</span>
2710                 width = max(cellfun(@length, arr), [], 1);  <span class="comment">% find largest column widths, force calculating maximum along rows</span>
2711                 strs = cell(1, numel(sp) + size(sp,1) + 1);  <span class="comment">% number of elements + line terminator for each row + end terminator</span>
2712                 k = 1;
2713                 strs{k} = sprintf(<span class="string">'%s %*s'</span>, <a href="../../../src/@RemoteControlBoardRemapper/open.html" class="code" title="function open(obj,partList,jointsList)">open</a>, width(1), arr{1,1});
2714                 <span class="keyword">for</span> j = 2 : size(sp,2)
2715                     k = k + 1;
2716                     strs{k} = sprintf(<span class="string">'%s %*s'</span>, colsep, width(j), arr{1,j});
2717                 <span class="keyword">end</span>
2718                 k = k + 1;
2719                 strs{k} = linesep;
2720                 <span class="keyword">for</span> i = 2 : size(sp,1)
2721                     k = k + 1;
2722                     strs{k} = sprintf(<span class="string">'%s %*s'</span>, rowsep, width(1), arr{i,1});
2723                     <span class="keyword">for</span> j = 2 : size(sp,2)
2724                         k = k + 1;
2725                         strs{k} = sprintf(<span class="string">'%s %*s'</span>, colsep, width(j), arr{i,j});
2726                     <span class="keyword">end</span>
2727                     k = k + 1;
2728                     strs{k} = linesep;
2729                 <span class="keyword">end</span>
2730                 k = k + 1;
2731                 strs{k} = close;
2732                 str = cell2mat(strs);  <span class="comment">% join strings into a single string</span>
2733             <span class="keyword">end</span>
2734         <span class="keyword">end</span>
2735     <span class="keyword">end</span>
2736     methods (Static, Access = private)
2737         <a name="_sub80" href="#_subfunctions" class="code">function sympoly_object = convertscalarsym(sym_object)</a>
2738         <span class="comment">% Create symbolic polynomial based on sym object.</span>
2739         <span class="comment">%</span>
2740         <span class="comment">% See also: sym</span>
2741 
2742             sympoly.symassignincaller(sym_object);    <span class="comment">% minimize collision of variable names by invoking a separate function</span>
2743             sympoly_object = eval(<a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(sym_object));  <span class="comment">% eval uses variables that have been created in this function context</span>
2744         <span class="keyword">end</span>
2745 
2746         <a name="_sub81" href="#_subfunctions" class="code">function symassignincaller(sym_object)</a>
2747         <span class="comment">% Create symbolic polynomial variables in the caller workspace from sym object.</span>
2748         <span class="comment">%</span>
2749         <span class="comment">% See also: sym, symvar</span>
2750 
2751             vars = symvar(sym_object);  <span class="comment">% list of symbolic variables in symbolic expression</span>
2752             <span class="keyword">for</span> k = 1 : numel(vars)
2753                 var = <a href="#_sub59" class="code" title="subfunction str = char(sp)">char</a>(vars(k));  <span class="comment">% name of variable as a string</span>
2754                 assignin(<span class="string">'caller'</span>, var, <a href="sympoly.html" class="code" title="">sympoly</a>(var));  <span class="comment">% create symbolic polynomial variable of the same name in the caller workspace</span>
2755             <span class="keyword">end</span>
2756         <span class="keyword">end</span>
2757     <span class="keyword">end</span>
2758     methods (Access = private)
2759         <a name="_sub82" href="#_subfunctions" class="code">function sv = variablename(sp, var)</a>
2760         <span class="comment">% Deduce default variable from context if not explicitly specified.</span>
2761 
2762             <span class="keyword">if</span> nargin &lt; 2 || isempty(var)   <span class="comment">% take default variable</span>
2763                 assert(<a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(sp), <span class="keyword">...</span><span class="comment">  % only if there is only one variable in the sympoly</span>
2764                     <span class="string">'math:sympoly:ArgumentCountMismatch'</span>, <span class="keyword">...</span>
2765                     <span class="string">'Variable to perform operation with respect to cannot be deduced from the context.'</span>);
2766                 sv = <a href="#_sub85" class="code" title="subfunction var = univariatesym(sp)">univariatesym</a>(sp);
2767             <span class="keyword">elseif</span> isa(var, <span class="string">'sympoly'</span>)
2768                 assert(<a href="#_sub33" class="code" title="subfunction tf = issinglevariable(sp)">issinglevariable</a>(var), <span class="keyword">...</span>
2769                     <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
2770                     <span class="string">'A single-term degree-one variable with unit coefficient is expected.'</span>);
2771                 sv = <a href="#_sub85" class="code" title="subfunction var = univariatesym(sp)">univariatesym</a>(var);
2772             <span class="keyword">elseif</span> iscellstr(var) &amp;&amp; numel(var) == 1
2773                 sv = var{1};
2774                 <span class="keyword">if</span> isa(sv, <span class="string">'symvariable'</span>)
2775                     validateattributes(sv, {<span class="string">'symvariable'</span>}, {<span class="string">'scalar'</span>});
2776                 <span class="keyword">else</span>
2777                     validateattributes(sv, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});  <span class="comment">% check for proper variable name</span>
2778                 <span class="keyword">end</span>
2779             <span class="keyword">else</span>
2780                 sv = var;
2781                 <span class="keyword">if</span> isa(sv, <span class="string">'symvariable'</span>)
2782                     validateattributes(sv, {<span class="string">'symvariable'</span>}, {<span class="string">'scalar'</span>});
2783                 <span class="keyword">else</span>
2784                     validateattributes(sv, {<span class="string">'char'</span>}, {<span class="string">'nonempty'</span>,<span class="string">'row'</span>});  <span class="comment">% check for proper variable name</span>
2785                 <span class="keyword">end</span>
2786             <span class="keyword">end</span>
2787         <span class="keyword">end</span>
2788 
2789         <a name="_sub83" href="#_subfunctions" class="code">function dim = operatingdimension(sp, dim)</a>
2790         <span class="comment">% Dimension an accumulator operation operates on.</span>
2791 
2792             s = size(sp);
2793             np = ndims(sp);
2794 
2795             <span class="comment">% default for dim is 1, UNLESS sp is a row vector.</span>
2796             <span class="keyword">if</span> nargin &lt; 2 || isempty(dim)
2797                 <span class="keyword">if</span> s(1) == 1 &amp;&amp; np == 2  <span class="comment">% a row vector</span>
2798                     dim = 2;
2799                 <span class="keyword">else</span>  <span class="comment">% any other shape array</span>
2800                     dim = 1;
2801                 <span class="keyword">end</span>
2802             <span class="keyword">else</span>
2803                 validateattributes(dim, {<span class="string">'numeric'</span>}, {<span class="string">'scalar'</span>,<span class="string">'integer'</span>,<span class="string">'positive'</span>});
2804             <span class="keyword">end</span>
2805             assert(dim &lt;= np, <span class="keyword">...</span>
2806                 <span class="string">'math:sympoly:DimensionMismatch'</span>, <span class="keyword">...</span>
2807                 <span class="string">'Accumulator would operate on dimension %d but array has only %d dimensions.'</span>, dim, np);
2808         <span class="keyword">end</span>
2809 
2810         <a name="_sub84" href="#_subfunctions" class="code">function var = univariatesym(sp)</a>
2811         <span class="comment">% The variable a univariate polynomial is a function of.</span>
2812         <span class="comment">%</span>
2813         <span class="comment">% Output arguments:</span>
2814         <span class="comment">% var:</span>
2815         <span class="comment">%    a variable name as a string or a cell array of variable names</span>
2816 
2817             validateattributes(sp, {<span class="string">'sympoly'</span>}, {<span class="string">'scalar'</span>});
2818             assert(<a href="#_sub31" class="code" title="subfunction tf = isunivariate(sp)">isunivariate</a>(sp), <span class="keyword">...</span>
2819                 <span class="string">'math:sympoly:InvalidOperation'</span>, <span class="keyword">...</span>
2820                 <span class="string">'Operation supported on univariate polynomials only.'</span>);
2821 
2822             <span class="keyword">if</span> iscell(sp.Variables)
2823                 var = sp.Variables{1};
2824             <span class="keyword">else</span>
2825                 var = sp.Variables(1);
2826             <span class="keyword">end</span>
2827         <span class="keyword">end</span>
2828     <span class="keyword">end</span>
2829 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 10-Jul-2018 15:03:35 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>